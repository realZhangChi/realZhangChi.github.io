---
layout: post
title: "策略模式"
subtitle: "Strategy Pattern"
author: "Chi"
date: 2020-08-31 10:00
header-style: text
catalog: true
tags:
  - Design Patterns
---

我们在讨论设计模式时，是在面向对象设计的思想之上来讨论的，在理解各种设计模式时，是离不开**抽象**、**继承**、**多态**等思想的。

在开始讨论**策略模式**前，让我们首先看一些设计原则。

## 设计原则

### 封装变化

> Identify the aspects of your application that vary and separate them from what stays the same.

找出代码中逻辑会发生变化的部分，把它与不会发生变化的部分分离开来，并将会发生变化的部分进行封装，这样我们就可以很容易地去选择或者扩展会发生变化的部分，而不会影响到程序中不会发生变化的部分。

在《Head First Design Pattern》一书中，使用了“模拟鸭子”游戏作为示例。鸭子是会飞的，“飞”是鸭子的**行为**，但对不同种类的鸭子，“飞”这一行为不尽相同，橡胶玩具鸭子甚至不会飞。如果通过面向对象思想中的继承来实现鸭子的“飞”的行为，将会导致代码维护困难。

实际上，“飞”这一行为，从代码的角度来讲，是会发生变化的，不同的鸭子有不同的方式。我们在进行类设计的时候，就可以找出“飞”这一会发生变化的行为，把它从类中剥离出来，让“变化”与“不变”保持独立，并将“变化”进行封装，不同的行为拥有不同的实现。

封装变化，封装的是类的行为，是行为的算法（执行这个行为的具体不同的方式）。

### 面向接口编程，而不是面向具体实现

首先需要指明的是，这里所说的面向的接口，不是编程语言中的接口——如C#中的`interface`，而是一种程序设计中的抽象，因此也可以将其理解为**面向抽象编程，而不是面向具体实现**。其中**抽象**可以通过多种方式来实现，通常会是`interface`。我们在理解面向接口编程的时候，需要注意区分概念。

利用面向接口编程，我们可以很容易地实现封装变化。我们可以将“飞”这一行为抽象成`interface`，作为类的一个字段，我们可以将“飞”行为的任何一个实现赋值给这个字段，这意味着这个类永远不会知道这个字段具体是什么类型。所有的鸭子都会飞，但是我们不去关心它怎样飞，甚至它可以什么都不做（方法不执行任何代码）！

利用面向接口编程，我们将“飞”这一会变化的行为，进行了抽象与封装，与类中不变的部分保持了独立，并且类将不再关心这一行为的变化。

得益于封装变化及面向接口编程的好处，我们还可以动态地更改对象地行为，比如通过构造函数，或者属性的`set`。

### 优先使用组合，而不是继承

使用组合能够拥有更高的灵活性，我们不仅可以将一系列算法进行封装，并且可以在运行时动态的更改类的行为。

## 策略模式

将以上描述的三种设计模式，组合运用起来，就是策略模式🎉。

策略模式定义了一系列算法，并将其每一个都进行了封装，并且让他们可以互相替换。策略模式让算法的变化独立于使用此算法的对象。
