---
layout: post
title: "《CQRS Documents by Greg Young》翻译：事件作为存储机制"
subtitle: 'CQRS Documents by Greg Young - Events as a Storage Mechanism'
author: "Chi"
date: 2020-06-12 10:00
header-style: text
catalog: true
tags:
  - Design Patterns
  - DDD
  - CQRS
---

大多数系统都依赖于当前状态的存储来处理事务，除了将当前状态存储起来外，很少见到开发人员以任何其他方式维护当前状态。

在普遍以关系型数据库`RDBMS`作为系统的中心之前，很多系统——尤其是在高性能、高安全度的系统中——并不会存储当前状态。如果我们研究`RDBMS`的内部原理，我们会发现大多数RDBMS本身实际上无法通过管理当前状态来工作！

这篇文章将介绍事件溯源的概念及其优点，展示如何利用关系数据库创建一个简单的事件存储系统进行底层数据管理。

## 什么是领域事件

**事件是过去发生的事情。**

所有事件都应该用过去式的动词来表示，如`CustomerRelocated`、`CargoShipped`、`InventoryLossageRecorded`，他们指的是**过去已经完成**的事情。在创建领域事件时，要避免使用名词，坚持使用过去式的动词。

事件使用过去式的动词是非常有必要的，因为事件是领域驱动设计中通用语言（Ubiquitous Language）的一部分。当我们讨论“更改客户地址”这一操作给系统中的数据带来的改变时，引入领域事件会使数据发生的变化这一概念变得明确，而以前在一个聚合根内或多个聚合根之间会发生的变化是一个隐式的概念，需要花费时间探索和定义。举个例子，在大多数系统中，数据发生变更只是被`Hibernate`或`Entity Framework`等工具发现，数据发生的变化是一个隐含的概念。事件的引入使得这个概念变得显性，成为通用语言的一部分：“更改客户地址”并不仅仅是改变一些东西，“更改客户地址”会产生一个CustomerRelocatedEvent，这个事件在语言中是显性定义的。

在代码方面，事件只是一个数据存储的结构：

``` C#
public class InventoryItemDeactivatedEvent
{
    public readonly Guid InventoryItemId;
    public readonly string Comment;
    public InventoryItemDeactivatedEvet(Guid id, string comment)
    {
        InventoryItemId = id;
        Comment = comment;
    }
}
```

这里的代码和命令`Command`的代码很相似，不同之处在于他们的命名和他们的目的。命令要求系统执行操作，事件记录已经发生的行为。

## 其他定义和讨论

> 将人们在某地与某物交互的事件用事务对象建模、将一个时间点的交互事件建模为一个单一时间戳的事务、将一个时间间隔的交互事件建模为一个多时间戳的事务。(Jill Nicola, 2002ll, p. 23)
> Model the event of people interacting at a place with a thing with a transaction object. Model a point-in time interaction as a transaction with a single timestamp; model a time-interval interaction as a transaction with multiple timestamps. (Jill Nicola, 2002ll, p. 23)

与这一描述相关的概念是“领域事件”（Domain Event），这个概念是在精简对象建模（Streamlined Object Modeling, SOM）中定义的。很多人在`SOM`中讨论事件原则（The Event Principle）时，都会使用“领域事件”这个术语。

尽管许多人使用领域事件这一术语来描述此概念，但是在本文档中，领域事件的定义与这一描述是不同的，`SOM`使用另一种术语——事务——来描述对象。事务对象的概念在领域中是一个重要的概念，一个事务可能是游戏玩家操控蝙蝠飞行，这一事务是在给定时间点发生的动作，应在领域中进行此类建模，但它与本文讨论的领域事件是不同的。

这也与马丁·福勒（Martin Fowler）关于领域事件的例子有所不同：

> 范例：我星期二去Babur's吃一顿饭，然后用信用卡付款。这可能被建模为一个事件，其类型为“Make Purchase”，付款方式为我的信用卡，事件发生日期为星期二。如果Babur's手工记账，并且直到星期五才将这一交易录入到银行，那么通知我发生交易的日期将是星期五。 (Fowler)
> Example: I go to Babur’s for a meal on Tuesday, and pay by credit card. This might be modeled as an event, whose type is “Make Purchase”, whose subject is my credit card, and whose occurred date is Tuesday. If Babur’s uses and old manual system and doesn’t transmit the transaction until Friday, then the noticed date would be Friday. (Fowler)

更进一步：

> “通过将系统的输入集中到领域事件中，您可以记录系统的所有输入。这可以帮助您组织处理逻辑，还可以保留系统的操作日志。”(Fowler)
> "By funneling inputs of a system into streams of Domain Events you can keep a record of all the inputs to a system. This helps you to organize your processing logic, and also allows you to keep an audit log of the system"(Fowler)

有些人可能会指出马丁举得这个例子是我们之前讨论基于任务的UI时所提到的“**命令**”。实际上使用“Make Purchase”这一单词是不正确的。支付已经发生了，如果我们引入`PurchaseMade`事件会更好。“马丁购买**了**一份食物，并通过信用卡付**了**款，然后吃完**了**食物。”所有的事情都是过去式的，他们都是已经发生了的而且不可改变了。

在实际项目中可能会有一些其他问题，领域可能需要对事件进一步完善。比如一个领域处理销售的系统，营业税额是多少呢？通常领域会负责营业税额的计算。这就导致了领域事件的双重定义：客户端传输到系统中的一个事件是没有计算税费的，领域接收到这个事件后计算出他的税费作为另一个包含税费的事件，这导致了事件的双重定义或强制使事件的某些属性可变。双重事件可以解决类似税费的问题（一个为客户端定义了它所要提供的内容，另一个为领域定义了包含来自客户端的以及需要领域完善的内容），但这都是是命令事件模型，并且语言上的问题（比如时态）仍然存在。

在一些发生错误的情况下也会发现语言上的问题，比如领域应如何处理客户端要求的不可能完成的任务呢？可能存在这种情况的例子有很多，客户端没有提供足够的信息来记录事件就是一个最简单的例子。从语言的角度来讲，命令/事件分离是十分有意义的，命令是一个进行时的时态，是一个祈使句（imperative），如“Place Sale”，而事件是过去时的“SaleCompleted”。对于领域来说，拒绝客户端“要进行销售”的请求是很正常的，但是领域被告知“一个已经发生的事情没有发生”是违反常理的。

上述情形正是命令与事件分离的根本原因。这种分离使代码更清晰，开发人员仅仅通过所使用的单词就可以更透彻得理解上下文。对概念的双重定义导致了开发人员不得不根据上下文来进行区分，增加了团队新成员熟悉代码的事件，也给团队成员带来了更多需要“记住”的东西。每当开发人员需要根据记忆中的东西来区分上下文时，开发人员则往往会混淆这些上下文。语言明确、避免双重定义，有助于领域专家、开发人员和所有与此相关的人员对此都更加清楚。

## 事件作为存储机制

当设计一个对象的持久化时，人们大多数会从这个对象的结构进行设计。比如“订单”，可能会存储为一个包含“订单项”及“收货地址”的“订单”，但这不是唯一方案。

考虑一个销售系统中的订单对象，大多数开发人员会从对象结构的角度进行设计，最终订单对象将和下图类似，一个订单对象包含一个收货信息和N条订单项。当然这只是一个简化的模型，但是足以表示出设计的重点是放在了订单及其订单部分等结构上。

![A Structural View of an Order](/img/in-post/2020-06-04-EventsAsAStorageMechanism/AStructuralViewofanOrder.png)

这并不是组织存储数据的唯一方案。我们提到过事务，事务可以代表着一个点与下一个点之间的变化，这种变化通常成为“增量”。可以在两个静态状态之间定义增量，但这种增量通常降级为了`ORM`框架中的隐式概念。`ORM`保存了数据的原始状态，与新状态进行比较找出变更并对其进行更新。明确定义这些增量无论是在技术层面还是业务角度上都有很大的好处。

很多成熟的商业系统中都应用了“增量”。“用户账户”是一个应用“增量”的典型例子。下图所示的分类账中的`Change`记录了每一个交易或者说“增量”，`Current Balance`记录了账户余额，也就是执行增量操作后的状态。最新一条记录的`Current Balance`就是当前账户的实际余额，我们完全可以认为这个值是正确无误的，因为我们随时可以从最开始重新运行账户交易流程来验证这个数值的正确性。

![A Simplified Ledger](/img/in-post/2020-06-04-EventsAsAStorageMechanism/ASimplifiedLedger.png)

我们可以一步一步执行这些交易或者增量来验证`Current Balance`的正确性。任一点的`Current Balance`我们既可以从这个字段中获取，也可以从账户创建时间开始对`Change`逐个计算获得。

这种标识状态的机制还有一些其他有用的功能，比如我们可以回到过去的某个时间点并看看当时发生了什么。考虑到`Current Balance`字段可以存储负数，而我们的业务规则要求账户余额不能是负数。如果有一个交易导致用户账户余额变成了负数，我们就可以很简单的回到这条交易执行之前的时间点来查看到底发生了什么，这样就可以很容易地重现出现错误的场景。

当应用领域驱动设计（Domain Driven Design）时，每个领域都是一个基于自然事务的领域，但是上述所说的各种好处不仅仅是局限于此的。领域驱动设计会关注与系统使用场景相符的行为，领域驱动设计感兴趣的是用户会如何使用这个系统。

回到上文提到的“订单”的例子，它也可以通过下图这种“事务模型”的形式来设计：

![Transactional View of Order](/img/in-post/2020-06-04-EventsAsAStorageMechanism/TransactionalViewofOrder.png)

这种类型的设计可以应用到所有类型的对象上。通过重新模拟一遍事件发生流程，我们能够得到此对象最终的状态，这与只存储最终状态效果是相同的。有一种非常有趣的情况，与以结构方式存储当前状态不同，域中的当前状态表示与存储中的存储状态之间没有耦合的情况不同，域中当前状态的表示可以在不考虑持久性机制的情况下发生变化。

**上图中所使用的词汇尤其需要注意！** 所有的动词都是**过去时**，说明他们是领域事件。考虑一下如果他们使用命令式时态会怎么样呢？比如“添加（Add）2只袜子到购物车”，如果存在与“添加”相关联的行为，例如扣减库存，该行为应该在此时发生吗？如果逻辑发生了变化导致在当前上下文中无法执行此命令该怎么办呢？这是命令`Commands`和事件`Event`之间需要双重上下文的众多例子之一，返回给定状态和试图过渡到新状态之间存在上下文差异。

## 不存在“删除”操作

一个问题是在这种模式下应如何执行删除操作呢？正如前文做说的，不存在可以把我们带到过去并让我们把已经发生的事情变成未发生的时光机。因此我们有必要将删除操作显式地建模为一个新的事务，如下图所示。有关通过此机制执行删除对业务所产生的价值，可参见“事件日志的业务价值”。

![Transactional View of Order with Delete](/img/in-post/2020-06-04-EventsAsAStorageMechanism/TransactionalViewofOrderwithDelete.png)

在上图中我们向购物车中添加了两双袜子，随后又将它们移除了购物车。购物车最终状态和添加袜子之前的状态是一样的，但是相关数据并没有被删除，而是记录了新的数据让购物车的最终状态和原来一致，就像事件没有发生一样。这一过程被称为“反向事务（Reversal Transaction）”。

通过在事件流中放置一个反转事务使对象与未添加项目前的状态一样，而不是直接更改对象。反转会留下一条记录，显示对象在某一特定时间点曾处于该状态。

这种方式从系统架构层面上来讲也有很多好处。存储系统变成了一个“仅添加”的架构，众所周知，仅添加架构比可更新架构性能更好，因为要处理的数据库锁更少。

## 性能和可扩展性

事件存储作为一个仅添加的模型，能够很容易地进行扩展。此外，在性能和可扩展性方面还有其他的优势，特别是与传统关系模型相比。例如，因为事件存储仅限于一个单一的附加模型，所以能够以一个更简单的机制来优化。时间存储机制还有很多其他好处：

### 分区

一个常见的性能优化方案是对数据库水平分区。同一结构的数据根据其某个键存在不同的表中。其基本思想是我们可以在多个分区中维护同一结构的数据，并根据数据的某个键来决定将其存到哪一个表中。

使用水平分区的一个问题是我们不得不定义作为分区依据的键。如果我们使用事件存储机制的话就不会存在这个问题了。**聚合`Id`是系统中唯一的分区点。** 无论存在多少聚合或它们如何改变结构，与事件关联的聚合`Id`都是系统中唯一的分区点。

水平分区事件存储是一个很简单的过程。

### 保存对象

在使用关系型数据库的传统架构中，想要弄清楚聚合中发生的变化通常会很麻烦。人们创建了很多工具，以帮助减轻这种复杂的任务所带来的痛苦，但对工具的需求是否意味着这是一个更大的问题？

大多数`ORM`框架能够发现“图”中所发生的变化。它们通常通过维护一个给定图的两个副本来实现这一点，第一个副本保存在内存中，第二个副本允许其他代码与之交互。当要将一段代码所执行的复杂操作进行保存的时候，`ORM`会将两个副本进行比较，查找出发生的变化，然后将这些变化保存到数据库中。

在一个以领域事件为中心的系统中，聚合本身就是在跟踪着事件，了解其内部发生了什么变化。没有复杂的比较两个副本的过程，而是简单地询问聚合的变化。询问变化的操作远比要弄清楚什么东西发生了变化要高效得多。

## 加载对象

在加载对象时也存在类似的问题。在一个使用了关系型数据库的系统中，为了加载出一些对象，通常会执行很多查询语句。为了将这些查询的延迟成本降到最低，许多`ORM`引入了`Lazy Loading`，也称为`Delayed Loading`，只有当代码试图该特定对象时，才会加载数据。

懒加载是很有用的，因为很多时候，一个给定的行为只会使用聚合中的某一部分数据，它可以避免开发者在降低集合的加载成本时，必须明确表示需要的是哪些数据。正是这种降低加载成本的需求，显示出了一个问题。

> 聚合被视为一个整体，由聚合根表示。从概念上讲，一个聚合是整体加载和保存的。(Evans, 2001)
> Aggregates are considered as a whole represented by the Aggregate Root. Conceptually an Aggregate is loaded and saved in its entirety. (Evans, 2001)

从概念上讲，加载或保存整个聚合要容易得多。延迟加载的概念在添加时并非不重要，尤其在优化使用场景时更为重要。从关系数据库中加载完整聚合的操作太慢，因此我们需要一个解决方案。

在事件作为存储机制的系统中是完全不同的，这种情况下只有一种东西——事件——被存储下来了。只需要加载一个聚合根的所有事件，并重现他们就可以了。这样的话系统永远就只需要进行一条查询指定，而且也不再需要延迟加载。

很多人会发现，尽管传统方式会进行多次查询，但是有些聚合所存储的事件可能会是一个非常庞大的数量。这种情况很常见，针对这个问题也有一个相对简单的解决方案。

## 快照

快照表示了一个聚合在指定时间点前的所有事件都被执行后的状态。快照被用来避免每次都需要从数据库中查出所有的事件。下图展示了一个事件流，处理事件流的一种方法是从头开始重现事件直至结束。

![An Event Stream](/img/in-post/2020-06-04-EventsAsAStorageMechanism/AnEventStream.png)

从最开始到现在这段时间可能存在成千上万的事件，这么多的事件全部加载是不现实的。

通过向特定时间点插入快照，在加载聚合的时候只需从那个时间点作为开始以快照为基础加载并重现事件即可。

![Event Stream with Snapshot](/img/in-post/2020-06-04-EventsAsAStorageMechanism/EventStreamwithSnapshot.png)

上图展示了在事件流中加入了快照的模型。因为快照的引入，通过数据库构建出聚合的过程变得不一样了。和从头加载事件不同，从最后开始读取事件放入栈中，直到读取完所有事件**或**读取了一个快照。以这个快照作为基础，将事件逐个出栈并应用到快照上，知道栈为空。

*值得注意的是，这里描述的只是简单的快照工作原理，在实际生产环境中要复杂得多。快照的实现将在“创建事件存储机制”中深入讨论。*

快照只是一个指定时间点的对象，**快照保存了这个时间点的状态信息，因此能够避免执行这个快照之前的事件**。可以通过监听事件存储的进程来异步获取快照。

快照的引入有助于控制加载事件的成本，可以调整要处理的最大事件数来优化系统性能。快照的引入可以很轻松地将基于事件存储的系统的性能大幅提升。需要记住的是，快照只是一个启发式的方法，从概念上讲，事件流仍然是完整地被加载的。

## 阻抗失配

使用事件作为存储机制的系统面对阻抗不匹配的问题时，与传统的关系模型或面向对象的领域模型比起来，拥有一些非常不同的特性。Scott Ambler在agiledata.org上的一篇文章中对这个问题进行了探讨：

> “为什么会出现阻抗失配的问题呢？面向对象的范例基于成熟的软件工程原理，数据库关系范式基于成熟的数学原理，由于基础范例不同，因此两种技术无法无缝协作。当分析访问数据的方式时，阻抗不匹配会变得很明显：使用对象范例，您可以通过对象之间的关系遍历对象，而使用关系范例，则可以连接表的数据行。这种根本的差异导致对象技术和关系技术的不理想结合。想想您有什么时候将两个不同的事物一起使用而又没有障碍吗？”(Ambler)

领域模型和关系数据库之间的阻抗不匹配，会带来很大的成本问题。有很多工具致力于解决领域对象模型和关系模型之间的阻抗不匹配问题，例如Object Relational Mappers(ORM)。他们大多数时候工作良好，但即使使用ORM等工具，仍然有相当大的成本与阻抗失配相关。

面对阻抗失配，开发人员必须深入掌握关系**和**领域对象这两种模型，熟悉两种模型之间的细微区别。

> “要想结合使用领域对象模型和数据库关系模型，你必须理解这两者的设计原理，以及他们之间的差别，然后根据所掌握的这些只是来灵活应变。”(Ambler)

这两种模式下的一些细微差别，可以从维基百科的“[Object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)”中了解到，其中还包括了一些高级知识。

*声明式接口 vs. 命令式接口：关系模型中倾向于将数据作为接口，而不是将行为作为接口，因此，与`OO`相反，它在设计理念上具有声明式接口的倾向。（一些关系模型的支持者建议使用触发器、存储过程等来提供复杂的行为，但这并不是常用的方案）（Object-Relational Impedance Mismatch）*

*结构 vs. 行为： `OO`主要致力于确保程序结构合理（易维护、易理解、易扩展、可重用、安全性高），而关系系统则侧重于运行中的系统其行为特点（效率、适应性、容错性、实时性、逻辑完整性等）。面向对象通常假设方法及接口的使用者是这个程序的开发人员，在关系系统中，最终用户对系统行为的看法有时被认为更为重要。关系查询和“视图”是在特定于应用程序或任务的配置中重新表示信息的常用技术。此外，关系型并不禁止创建本地的或特定于应用程序的结构或表，但许多常见的开发工具并不直接提供这样的功能，而是假设会使用对象。这就很难知道所说的最终用户对系统的开发指的是关系型所固有的，还是仅仅是通过工具事件后的。*

*集合 vs. 图： 不同项目(对象或记录)之间的关系往往在不同的范式中得到不同的处理。关系模型通常基于集合理论，而对象关系则基于图论（包括树）。虽然每一种都可以表示相同的信息，但它们提供的访问和管理信息的方法是不同的。*

还有很多其他不同，比如数据类型、验证、事务工作原理等。处理对象-关系阻抗失配的问题会相当痛苦，我们需要拥有大量的相关知识才能有效地处理。

**在事件和领域模型之间不存在阻抗失配的问题。** 事件本身就是一个领域上的概念，通过重现事件来得到对象的状态也是一个领域概念，整个系统都通过领域术语进行了定义。用领域术语定义所有内容，不仅降低了开发人员需要掌握的知识量，因为事件与领域模型本身直接相关，还降低了所需的模型数量。

## 事件日志的业务价值

*这一节中首先要明确的是，事件日志的价值与使用领域驱动设计的原因直接相关。领域驱动设计应该用在公司的业务已经在领域中占据优势的情况下。领域驱动设计的应用是非常困难的，带来的成本也会很高昂。然而，如果一个公司的领域是复杂的，并且这个公司已经在此领域中占据一席之地，那么就应该将领域驱动设计应用进来。在拥有竞争优势的领域中，使用事件日志同样会有很高的投资回报率，但在其他地方可能会相反。*

只存储当前状态则只允许询问某些类型的数据问题。例如考虑股票市场中的订单，可能会更改交易订单中买入或卖出的数量，交易系统可以自动调整订单中的数量。如果我们关注市场的整体走势，那么我们就不会关心他们是发生了哪些变化，**如何**发生的变化，而是会关心这些时间他们**是什么**样的状态。在真实场景中我们关心的都是“**是什么**”。

在一些业务场景下也有很多查询类型关注“如何（How）”,在“商业智能”中有一些例子。购买产品的可能性与这个人的行为是否有关联呢？这种问题关注点在于事物是**如何**发生的，而不是发生了什么。

最好通过一个例子来说明。有一个大型在线零售商的开发团队，在一次迭代规划会议上，一位领域专家提出了一个想法，他认为，人们从购物车中添加了然后又删除了一个商品，与他们在以后购买该产品的可能性之间存在相关性。这个功能被添加到系统下次的迭代中。

假设有一个开发团队通过传统架构来开发了这个系统，他们准备再增加一张表来记录用户添加又删除购物车的这一行为，并发布到下个版本迭代中来采集数据。然后再开发一个统计功能，将对下个版本采集到的数据进行统计分析并生成报告。

这时一个很典型的方案，很多开发团队都会采用，这让领域专家也感到很高兴，他们提出了需求然后开发人员很快地实现了。然而又另一个团队则完全不同。

另一个团队把事件都存储了下来，他们通过重现事件来表示某个对象的当前状态。这个团队和上一个团队一样添加了一张表来记录用户添加又删除购物车的行为，并根据此表来产生报告。但是这个团队还将从最开始知道现在所发生的相关事件进行重现，生成了数据并填充到新增加的表中。在下一次发布后，就能够看到过去所有相关的分析报告。

第二个团队能够实现这种效果是因为他们对系统中发生的事件进行了管理，而不是管理对象的当前状态，这样就可以用一个新的视角来查看过去的数据。这个团队以前从未想过要跟踪用户向购物车中添加了哪些商品、删除了哪些商品、添加又删除了多少次，但是这些问题都可以通过查看数据的新视角来统计出来结果。

**由于事件代表了每个动作，因此可以从这些事件中构建出多种不同的模型来描述这个系统。**

在业务中，通常会提出很多新颖有趣的数据查看方式，我们无法预测到五年后会以一个什么样的方式来查看现在的数据。在未来查看当前数据的方式是未知的，但这是非常有价值的。我们已经提到过这些模式应该用在企业已经取得了竞争优势的情况下，相对容易地以一种意想不到的方式查看当今数据的能力可能会成为企业的竞争优势。总的来说，不同的系统架构可能会影响到一家公司的成败。

传统模式下，软件团队如何证明他们对五年或十年后的预测是合理的呢？许多人使用YAGNI([You Ain’t Gonna Need It](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it))来说服自己，但是YAGNI只适合在确定不会需要他的情况，真正的业务是不断变化的，我们无法预测到五年或十年后需要以一种什么样的方式来组织查看数据。

- 对所有的行为进行建模会花费很多时间人力成本吗？是的。
- 将所有的事件存储到系统中会花费很多硬盘成本吗？是的。
- **如果我们能从这些数据中获得商业竞争优势的话，这些成本值得吗？**

## 引用

> - [CQRS Documents by Greg Young](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)
> - [Ambler, S. W. (n.d.). The Object Relational Mismatch.](http://www.agiledata.org/essays/impedanceMismatch.html
)
> - Evans, E. (2001). Domain Driven Design. Addisson Wesley.
> - [Fowler, M. (n.d.). Domain Event.](https://martinfowler.com/)
> - [Object-Relational Impedance Mismatch. (n.d.).](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)
> - [Wikipedia. (n.d.). You ain't gonna need it.](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)
