---
layout: post
title: "《CQRS Documents by Greg Young》翻译：基于任务的用户界面"
subtitle: 'CQRS Documents by Greg Young - Task Based User Interface'
author: "Chi"
date: 2020-04-29 14:00
header-style: text
catalog: true
tags:
  - Design Patterns
  - DDD
  - CQRS
---

这篇文章将介绍“基于任务的用户界面”，并与“基于CRUD的用户界面”进行比较。还会展示当基于任务的编码风格应用到系统中时，应用服务所产生的变化。

在上一篇文章中我们发现的最大的问题就是系统中没有显示出用户的操作意图，系统中没有富含领域知识。因为客户端通过来回传输DTO与应用服务端进行交互，所以领域中无法拥有任何领域对象的动作。此时领域已经变成了一个美化的数据模型的抽象，没有任何领域行为。而领域行为实际上分散到了客户端、笔记、用户的大脑中等很多地方。

说这种架构没有体现出用户意图的原因在于，`DTO`只保存了客户端完成某些操作时候的对象的状态。在系统中体现出用户的意图很简单，只要将应用服务改为处理用户行为而不仅仅是处理`DTO`就可以了。

![Behavioral Interface](/img/in-post/2020-04-29-CQRS-task-based-user-interface/behavioral-interface.jpg)

上图描述的客户端交互流程与上一篇文章中的`DTO`传输交互非常相似：客户端向服务端请求一个`DTO`,服务端将`DTO`返回给客户端，客户端对此`DTO`进行更改，至此为止一切都与原来的交互流程一样。

不同于原来客户端将更改后的`DTO`发送给服务端，上图的交互流程中，客户端将会向服务端发送一条指令来告诉服务端**要做什么事情**，比如“提交订单”、“更新个人资料”等。简单来说，客户端发送了一条指令告诉服务端来完成一件用户想要完成的事情。告诉服务端用户要做什么的这种方式，我们很容易了解用户的意图。

## 指令

指令是服务端被告知要做什么事情所调用方法的参数。指令可以是包含了指令名称及执行指令所需数据的一个简单的对象。

指令的一个重要方面是，它们总是一个命令式的，也就是说它总是会**命令**服务器去做什么事情。存在一种情况，销售系统客户端向服务端发送了一条`SaleOccurred`指令，要求服务器去做“售卖”这件事情。从领域的角度来看，是否允许服务端**拒绝**这条指令呢？无论是出于“库存”或一些其他原因，很显然我们是允许服务端**拒绝**这条指令的。简单来说，指令就是一条命令，客户端通过它来命令服务端去做什么事情，服务端可以**拒绝**这条指令。也存在*不*允许服务端拒绝的情景，但那不是指令，而是事件。

从英语中可以找到很多例子。比如一个单词“Purchase”购买，它既是动词，又可以作为名词来描述“购买”的结果。这种情况下，要确保我们的指令代表**去购买**的动词概念，而不是名词。`Purchase`应改是一个包含“去购买”意图，并让服务端来处理“某件商品被购买了”的指令，而不是一个详细的“购买清单”`DTO`。

``` C#
public class DeactivateInventoryItemCommand
{
  public readonly Guid InventoryItemId;
  public readononly string Comment;
  public DeactivateInventoryItemCommand (Guid id, string comment)
  {
    InventoryItemId = id;
    Comment = comment;
  }
}
```

上述代码中的指令包含了两条属性，其中一个是代表要要被禁用的库存项目的`Id`，另一个是为什么禁用的备注。备注是一个典型的与指令所关联的属性，它是执行指令所需要的数据。在指令上**仅**应存在处理给定行为所需的数据。这与典型的体系结构形成了鲜明的对比，在典型的体系结构中，对象的全部数据都传递回了服务端。

数据中最重要的是相关库存项目的`Id`。 对于所有以某种方式更新状态的命令，必须存在至少一个`Id`，因为所有命令都会关联到相关的对象。 发出“创建命令”时，则没必要再包含`Id`。

对于开发人员来说，了解命令并很快使用熟悉的词汇（例如“ ChangeAddress”，“ CreateUser”或“ DeleteClass”）开始创建命令是很常见的。尤其需要注意的是，我们应尽力避免这种情况。我们不应从所熟悉的词汇开始定义一个指令，而应该专注于指令的使用场景，通过定义使用场景来定义指令，对指令进行命名。

是“更改地址”吗？ “更改地址”和“重新定位客户”之间有区别吗？ 所涉及的领域可能是某个电话公司，该电话公司将文档邮寄到客户时将会发送到新位置。

是“创建用户”还是“注册用户”？ “删除班级”或“注销学生”？ 在这个命名过程中可以产生极大的领域洞察力，深入理解领域知识。**要开始定义指令，最好的开始就是定义使用指令的场景**。

另外，需要注意的是，有时对部分数据的唯一使用场景是“创建”、“编辑”、“更新”、“更改”或“删除”。所有的应用程序都包含这些简单操作，但重要的是，不要纠结于仅支持简单`CRUD`的那些使用场景
。

命令作为一个概念并不难，但许多开发者认为命令的创建是一个很大的工作。如果命令的创建成为了一个瓶颈，那么证明我们所讨论的这些理论知识被错误的使用了。

## User Interface

为了在系统中使用指令，`UI`层面上会与原先的`DTO`驱动的设计有所不同。因为`UI`必须构建出指令对象，所以`UI`要能够从用户的操作中得到用户的意图。

因此我们应设计"基于任务的用户界面（Task Based User Interface）"，它在微软的技术栈中被称为"感应式用户界面（Inductive User Interface）"，是一个以完全不同的另一个视角视角进行设计的用户界面。微软在研究感应式用户界面时，发现了非感应式用户界面的三个主要问题。

- **用户并没有构建出足够的产品概念模型。** 目前大多数软件产品的界面设计都假定用户会理解设计者精心制作的概念模型。但是大多数用户从来没有形成一个足够精确的概念模型来指导他们使用软件。用户没有时间、精力和欲望去琢磨软件的概念模型。

- **即使是很多老用户，也从未掌握过常用的程序。** 设计师们知道，新用户可能一开始会有问题，但随着用户学习使用常见的软件操作，这些问题会消失。可用性数据表明这种情况不会发生，用户在使用软件的时候，不会去留意他的操作流程，更不会从此次使用过程中收获经验。下次用户可能会以完全相同的方式跌跌撞撞地操作软件。

- **用户必须努力去琢磨每一个功能或画面。** 大多数软件产品是为了解其概念模型并掌握了常用程序的用户设计的。而对于大多数用户来说，每一个功能或程序都需要花费力气去掌握。用户可能会认为这是使用计算机的一种不可避免的成本，但如果没有这种负担，他们肯定会更快乐。*(Microsoft Corporation, 2001)*

**基于任务或感应式UI的基本理念是，弄清楚用户想要如何使用软件，并让软件来引导用户完成这些过程。**

>在许多商业软件中，某个用户界面显示了一系列的控件，但是由用户来推断页面的作用以及如何使用这些控件来实现用户的目的。*(Microsoft Corporation, 2001)*

我们的目标是引导用户完成操作。可以根据上面提到的`DeactivateInventoryItem`来展示两种用户界面的区别。一个典型的非感应式UI可能包含一个可编辑的表单，其中包含了所有库存项目的信息。其中会有一些可以编辑的字段，和一个下拉框来选择库存项目的状态，其中一个可选项就是“禁用”。为了禁用一个库存项目，用户需要先打开此库存项目的界面，将下拉框选中“禁用”，并输入“禁用备注”。如下图

![A Crud Screen for An Inventory Item](/img/in-post/2020-04-29-CQRS-task-based-user-interface/a-crud-screen-for-an-inventory-item.jpg)

如果用户选中了“禁用”但是没有输入“禁用备注”，则会提示用户“必填项不可为空”之类的内容。有些用户界面设计的足够好，会在用户选了“禁用”后才出现“禁用备注”这个输入项，这样会让用户更直观的知道这是一个必填项。但是这样的设计还不够好。

![Listing Screen With Link](/img/in-post/2020-04-29-CQRS-task-based-user-interface/listing-screen-with-link.jpg)

一个基于任务的用户界面将采取不同的方法，它可能会显示一个库存项目列表，在一个库存项目旁边可能会有一个链接来"禁用"该项目，如上图所示。用户点击这个链接后将会弹出一个界面，在这个界面中有一个输入框填写“禁用备注”。

![Deactivating an Inventory Item](/img/in-post/2020-04-29-CQRS-task-based-user-interface/deactivating-an-inventory-item.jpg)

这样设计，用户的操作意图很清晰，并且我们的软件一步步引导了用户完成操作。通过这种用户界面，我们能够很容易构建出一个表示了用户意图的指令。

Web、Mobile，尤其是Mac的UI一直在向着基于任务的方向发展。UI引导你完成一个过程，并提供操作指导，将你引导至正确的使用方向。这种风格提供了更好的用户体验。由于高度关注用户如何使用软件和为什么使用软件，用户的体验成为了流程中不可或缺的一部分。除此以外，我们将会更加注重用户**想如何使用该软件**，这是定义该领域一些动词的一个良好的开端。

## 引用

> [Microsoft Corporation. (2001, Feb 9). Microsoft Inductive User Interface Guidelines.](http://msdn.microsoft.com/en-us/library/ms997506)
> [CQRS Documents by Greg Young](https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf)
