[{"categories":["Abp极简教程"],"content":"从手动创建项目CatchException开始，添加Abp应用、模块来集成Abp框架。","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp是一个基于.NET的开源应用程序框架，它遵循最佳实践和约定，根据DDD模式进行设计和开发，并提供了强大的基础设施和完整的架构。 Abp提供了项目启动模板，它依据DDD模式进行分层，并预先配置了常用的模块。启动模板中反映着领域驱动设计、最佳实践等多种概念，其中任一项都值得单独讨论。对于初学者而言，启动模板中的大量知识如潮水般瞬间涌入脑海，造成知识过载，无法聚焦当前真正要学习的知识。 本系列教程，将结合一个问答网站CatchException示例项目，从简单的.NET Web Api应用程序开始，搭建起基于Abp的Web应用程序框架，并逐步深入细节，旨在以一种缓和的学习曲线帮助初学者快速入门。教程中的每一篇文章，都将会针对特定的几个知识点进行阐述，来帮助读者聚焦知识点。 关注代码 教程中会对必要的领域驱动设计概念进行简单的描述，如果在阅读本教程时对其感到困惑，那么暂时不要深入领域驱动设计的细节，请专注于代码及代码的设计思路。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"创建应用 通过VS创建一个名为CatchExceptionWeb Api应用，选择ASP.NET Core Web Api项目模板，或通过CLI执行dotnet new webapi -n CatchException。运行后将访问至Swagger页面。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"集成Abp 首先需要添加Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc Nuget包引用至项目中以集成Abp框架。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp应用 Abp框架中定义了IAbpApplication应用，项目启动时应构建应用并运行。应用包含了启动模块及其依赖，构建应用时需要指定启动模块。将Program.cs更改如下： var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); AddApplication扩展方法向依赖注入系统中注册单例的Abp应用，方法的泛型参数指定了启动模块，稍后在示例项目中将创建名为CatchExceptionModule的模块。 InitializeApplication扩展方法初始化Abp应用，它将会根据模块的依赖关系初始化启动模块及其依赖的模块。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"模块 创建C#类文件命名为CatchExceptionModule更改代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureSwaggerServices(context); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseConfiguredEndpoints(); } private static void ConfigureSwaggerServices(ServiceConfigurationContext context) { context.Services.AddSwaggerGen(); } } Abp设计为模块化的应用程序框架，每一个模块都应定义一个继承自AbpModule的类，并以Module后缀作为类名。不同的模块间会存在依赖关系，模块的依赖关系通过DependsOn特性来定义。每个C#项目只应定义一个模块。 在ConfigureServices方法中，可以将依赖项注册到依赖注入系统中。在Abp中，可以通过约定大于配置的方式进行依赖项注册，项目代码通常无需在这里手动注册。示例程序在ConfigureServices方法中注册了Swagger相关服务。ConfigureServices方法将在实例化Abp应用的时候调用。 初始化Abp应用时，将会按照依赖顺序初始化所有的模块。初始化启动项模块时将会调用他的OnApplicationInitialization方法，通常在这个方法中会构建中间件管道。示例程序配置了路由和终结点管道，并在开发环境中配置Swagger中间件。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"日志 添加Nuget包引用Serilog.AspNetCore、Serilog.Sinks.Async到项目中，并更改Program.cs。 try { Log.Logger = new LoggerConfiguration() #if DEBUG .MinimumLevel.Debug() #else .MinimumLevel.Information() #endif .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Async(c =\u003e c.File(\"Logs/logs-.txt\", rollingInterval: RollingInterval.Day)) #if DEBUG .WriteTo.Async(c =\u003e c.Console()) #endif .CreateLogger(); var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac() .UseSerilog(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly!\"); return 1; } finally { Log.CloseAndFlush(); } 在应用程序启动时，首先创建一个Serilog日志记录器，然后将构建并运行Web应用的操作通过try块包括起来捕获异常，在catch块中记录启动异常日志，在finally块中重置Serilog日志记录器。上述操作针对启动过程进行了日志记录，若要使应用通过Serilog记录日志，还需要UseSerilog扩展方法注册Serilog日志服务（第20行代码）。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:3","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"启动 启动应用此时应导航到Swagger页面并可调用WeatherForecast接口获取数据。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:4","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章展示了如何从ASP.NET Core Web Api模板开始，手动集成Abp框架并将项目模块化，以当前项目作为启动模块创建并运行Abp应用。这里简单介绍了Abp应用及Abp模块，后续文章将逐步介绍Abp中的其他概念及用法。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":[".NET"],"content":"如何在生命周期为Singleton的服务中，解析生命周期为Scoped或Transient的依赖项。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"在依赖注入系统中，依赖项的生命周期通常分为瞬时的（Transient）、作用域的（Scoped）、单例的（Singleton）三种。单例生命周期的服务通常会在首次调用时创建，后续每此调用都会使用同一实例。 单例服务若依赖其他生命周期为瞬时或作用域的服务时，无法通过构造函数注入依赖项。构造函数只会在创建实例时调用一次，若将依赖项通过构造函数注入并赋值给单例服务的本地成员，依赖项的生命周期结束后销毁后，指向依赖项的本地成员将会指向空引用，且永远不会再次被赋值（只在调用构造函数时赋值）。运行时会抛出异常Cannot consume scoped service 'XXX' from singleton 'XXX'.。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:0:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"解决方案 在依赖瞬时生命周期或作用域生命周期依赖项的单例服务中，不直接通过构造函数注入依赖项，而是注入IServiceScopeFactory，在需要用到依赖项的方法中，通过IServiceScopeFactory创建作用域并解析依赖项。 public class MySingletonService : IMySingletonService { private readonly IServiceScopeFactory _scopeFactory; public MySingletonService(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Scoped() { using var scope = _scopeFactory.CreateScope(); var ctx = scope.ServiceProvider.GetRequiredService\u003cMyDbContext\u003e(); } } ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:1:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":["ASP.NET Core"],"content":"配置在开发环境中使用HTTP而不是HTTPS，配置不同的端口号。","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["ASP.NET Core"],"content":"在开发ASP.NET Core的项目时，默认地是使用HTTPS安全协议的。有时候可能不希望在本地的开发环境中使用HTTPS，更改这一默认行为非常简单。 移除UseHttpsRedirection中间件 app.UseHttpsRedirection中间件会将所有HTTP请求重定向到HTTPS，因此首先我们需要将其删除。中间件配置一般在Program.cs或Startup.cs中。 配置launchSettings.json launchSettings.json在项目的Properties目录下，它只对本地的开发环境生效，部署时会被忽略。通过dotnet new或者Visual Studio生成的ASP.NET Core项目会创建launchSettings.json文件。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 44324 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"https://localhost:7072;http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 将applicationUrl从https更改为http即可更改默认的应用启动Url，若使用IIS启动，还需将iisSettings中的sslPort设为0。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 0 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 此外，在launchSettings.json中，也可以通过applicationUrl更改应用启动的端口号。 ","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/:0:0","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["abp"],"content":"在Abp框架中，如何将ExtraProperties额外属性作为查询条件进行数据检索。","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"Abp框架提供了实体扩展系统，允许在不对类的定义进行更改的情况下，向对象中添加额外的属性。默认地，额外属性是以json对象的形式存储在数据库表的ExtraProperties字段中，因此无法直接将额外属性作为查询条件。对于额外属性，Abp支持将其通过Entity Framework Core映射为数据库表的单独字段，因此我们可以利用数据库映射来实现根据额外属性进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:0:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"数据库映射 将额外属性映射为数据库表字段非常容易。 通过Abp启动模板创建的解决方案中，预先生成了处理数据库映射的*EfCoreEntityExtensionMappings类，它位于*.EntityFrameworkCore项目中。在项目启动时，将会执行其中的Configure方法，通过OneTimeRunner执行一次操作。 在OneTimeRunner.Run()方法的Action参数中，通过ObjectExtensionManager来处理额外属性到数据库表字段的映射。 ObjectExtensionManager.Instance .AddOrUpdateProperty\u003cIdentityUser, string\u003e( \"Gender\", options =\u003e { options.MapEfCore((b, p) =\u003e { b.HasIndex(\"Gender\"); p.IsRequired().HasDefaultValue(string.Empty); p.HasMaxLength(8); }); } ); 在AddOrUpdateProperty方法中还可以设置表字段长度等，也可设置表的属性如索引。 添加数据迁移脚本并运行*.DbMigrator更新数据库接口，可以看到表中多出一个名为Gender的字段。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:1:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"查询 在*.EntityFramework.Core项目中创建仓储，并创建查询方法。 public async Task\u003cIdentityUser\u003e GetUserByGenderAsync(string gender) { return await (await GetDbSetAsync()) .FromSqlRaw($\"select * from AbpUsers where Gender == '{gender}'\") .FirstOrDefaultAsync(); } 调用方法GetUserByGenderAsync并传入gender参数即可根据Gender进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:2:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"总结 在这篇文章中，描述了如何对额外属性进行数据库映射，以及将额外属性作为查询条件检索数据。值得注意的是，将额外属性作为查询条件并不是最佳实践，如果可能的话应当尽量避免。此外，如需将拥有额外属性的Entity通过AutoMapper映射为Dto，不要忘记对Dto进行扩展并配置AutoMapperProfile。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:3:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["maui"],"content":"如何在Maui中使用依赖注入","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"依赖关系注入(DI)是 .NET 中的一等公民，如果熟悉 .NET 开发，对依赖注入则不会陌生。依赖关系注入是一种在类及其依赖关系之间实现控制反转(IoC)的技术，其中要反转的是获取依赖项的过程。通过依赖关系注入，分离了对象构建和对象使用的关注点，提高了代码的可读性和重用性。 .NET Multi-platform App UI 框架支持依赖关系注入软件设计模式。在 MVVM 模式中，依赖注入通常用于注册和解析视图模型，并注册和解析视图模型所依赖的服务。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:0:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"容器 容器负责构造并注入服务，管理服务的生命周期。拥有依赖项的类，只需关注对于依赖项的使用，无需关注依赖项的创建与管理——这个过程由容器进行处理。.NET 中提供了内置的服务容器IServiceProvider，可以使用IServiceProvider来解析依赖的服务。 一般地，在应用程序启动时，将服务注册到IServiceCollection中，然后调用BuildServiceProvider扩展方法，即可得到IServiceProvider容器。 在 Maui 中，生成IServiceProvider的过程是框架自动完成的，只需要在MauiProgram.cs中将服务注册到IServiceCollection即可。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:1:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注册服务 在注入服务前，必须先将服务注册到容器中。Maui 内置的容器ISeviceProvider位于MauiApp中。 应用程序启动时，调用MauiProgram.cs中的 CreateMauiApp设置并构造MauiApp。首先调用 CreateBuilder创建一个构造器，通过这个构造器完成创建MauiApp所需的全部设置，其中包括服务注册，最终通过Build方法构造 MauiApp 实例。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); }); return builder.Build(); } } 在.NET中注册服务，就是在应用程序启动时，将服务注册到 IServiceCollection 中。在MauiAppBuilder中，存在IServiceCollection类型的属性Services。因此，在 Maui 应用程序中注册服务，只需在构造MauiApp时将服务添加到MauiAppBuilder中的 Services中。 public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); ... builder.Services.AddSingleton\u003cMainPage\u003e(); return builder.Build(); } 在进行依赖关系注入时，需要从容器中解析服务。通过调用IServiceCollection的扩展方法 BuildServiceProvider可以构造获取 IServiceProvider容器实例。 调用MauiAppBuilder的Build方法获取 MauiApp实例时，将调用BuildServiceProvider，构造出IServiceProvider并赋值给MauiApp中的Services属性。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:2:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注入服务 注册服务后，可以通过容器来解析服务实例，也可将其作为依赖项进行注入。 依赖关系注入通常有构造函数注入、属性注入与方法注入三种方式。在 Maui 中，一般会使用构造方法注入依赖项，在平台代码中有时也会直接通过MauiApp实例来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } 将MainPage注册到容器中后，可以通过构造函数注入的方式将其作为依赖项注入。在特定平台的代码中，有时无法使用构造函数注入，这时可以直接通过容器解析依赖项。 public class MyActivity : MauiAppCompatActivity { private readonly IHelloService _helloService; public MyActivity() { _helloService = MauiApplication.Current.Services.GetRequiredService\u003cIHelloService\u003e(); } } ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:3:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["Abp"],"content":"轻量化Abp框架","date":"2021-07-23","objectID":"/posts/lightweightabp/","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们…”。事实上，Abp框架真的很重吗？ 框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分： 所依赖程序集的数量 所实现的功能的多少 上手难度及易用性 “轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。 这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:0:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"最小依赖 Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了展示层、应用层、领域层与基础设施层。 我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。 从架构设计上来讲，模块化是Abp的核心；而从技术角度来看，依赖注入则是Abp实现众多功能的一个主要手段。只要了解Abp的模块化和依赖注入，我们就能够基于Abp框架来进行项目开发。 接下来将创建一个原生的ASP.NET Core Web API项目，围绕模块化和依赖注入两个核心概念，来展示如何以最小依赖的方式使用Abp。 通过VS或者dotNet cli新建一个原生的ASP.NET Core Web API项目，命名为LightweightAbp； 安装Nuget包Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc； 将项目进行模块化：在项目根目录新建一个Abp模块代码文件LightweightAbpModule.cs，并复制以下代码： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { } } 将Startup中的代码调整到LightweightAbpModule中，代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddControllers(); context.Services.AddSwaggerGen(c =\u003e { c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"LightweightAbp\", Version = \"v1\" }); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseSwagger(); app.UseSwaggerUI(c =\u003e c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"LightweightAbp v1\")); } app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers(); }); } } 更改Startup中的代码以使用Abp的模块化系统： public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddApplication\u003cLightweightAbpModule\u003e(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory) { app.InitializeApplication(); } } 更改Program的CreateHostBuilder方法以使用Abp的依赖注入系统（基于Autofac）： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseStartup\u003cStartup\u003e(); }) .UseAutofac(); 将项目生成的WeatherForecastController基类ControllerBase更改为AbpController。 按F5运行。 至此项目的创建完成了。可以看到，仅仅依赖了Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:1:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"功能按需使用 得益于模块化设计，Abp将其所能提供的功能，划分并封装到了不同的模块中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（DependsOn）模块即可。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"数据访问 要想实现数据访问功能，首先我们需要定义Entity、DbContext并配置数据库支持。在Abp的层次架构中，Entity、Repository属于领域层，Service属于应用层，DbContext则属于EntityFramework Core模块，因此我们按需引入所需模块即可。 安装Nuget包Volo.Abp.Ddd.Application、Volo.Abp.Ddd.Domain和Volo.Abp.EntityFrameworkCore.Sqlite； 在LightweightAbpModule类中配置DependsOn特性，将AbpDddApplicationModule、AbpDddDomainModule和AbpEntityFrameworkCoreSqliteModule模块依赖到我们的项目模块中。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpDddApplicationModule), typeof(AbpDddDomainModule), typeof(AbpEntityFrameworkCoreSqliteModule))] public class LightweightAbpModule : AbpModule { ... } 然后创建实体Book及数据库上下文LightweightAbpDbContext: using System; using Volo.Abp.Domain.Entities; namespace LightweightAbp { public class Book : Entity\u003cGuid\u003e { public string Name { get; set; } } } [ConnectionStringName(\"Default\")] public class LightweightAbpDbContext : AbpDbContext\u003cLightweightAbpDbContext\u003e { public LightweightAbpDbContext(DbContextOptions\u003cLightweightAbpDbContext\u003e options) : base(options) { } public DbSet\u003cBook\u003e Books { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); builder.Entity\u003cBook\u003e(b =\u003e { b.ToTable(nameof(Books)); }); } } 在LightweightAbpModule的ConfigureServices方法中配置数据库访问： public override void ConfigureServices(ServiceConfigurationContext context) { ... context.Services.AddAbpDbContext\u003cLightweightAbpDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseSqlite(); }); } 在appsettings.json中配置数据库连接字符串 { ... \"ConnectionStrings\": { \"Default\": \"Data Source=LightweightAbp.db\" } } 安装Nuget包\"Microsoft.EntityFrameworkCore.Tools\",并在在项目根目录下打开命令行工具，依次执行以下命令进行数据迁移和数据库更新： dotnet ef migrations add InitialCreate dotnet ef database update 创建IBookAppService及BookAppService: public interface IBookAppService { Task CreateAsync(string name); } public class BookAppService : ApplicationService, IBookAppService { public IRepository\u003cBook, Guid\u003e Repository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cBook, Guid\u003e\u003e(); public async Task\u003cstring\u003e CreateAsync(string name) { var book = await Repository.InsertAsync(new Book() { Name = name }); return book.Name; } } 在文件夹Controllers中创建BookController: [ApiController] [Route(\"[controller]\")] public class BookController : AbpController { private readonly IBookAppService _service; public BookController(IBookAppService service) { _service = service; } [HttpGet] public Task\u003cstring\u003e CreateAsync(string name) { return _service.CreateAsync(name); } } F5以调试模式运行即可在Swagger页面上插入数据： 这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 ASP.NET Core Web API方式进行开发。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:1","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"缓存 接下来我们将继续实现缓存功能。 引用Nuget包Volo.Abp.Caching并向LightweightAbpModule添加AbpCachingModule模块依赖； 修改IBookAppService及BookAppService实现GetAllAsync方法： public interface IBookAppService { Task\u003cstring\u003e CreateAsync(string name); Task\u003cstring[]\u003e GetAllAsync(); } public class BookAppService : ApplicationService, IBookAppService { private readonly IRepository\u003cBook, Guid\u003e _repository; private readonly IDistributedCache\u003cstring[]\u003e _cache; public BookAppService( IRepository\u003cBook, Guid\u003e repository, IDistributedCache\u003cstring[]\u003e cache) { _repository = repository; _cache = cache; } public async Task\u003cstring\u003e CreateAsync(string name) { ... } public async Task\u003cstring[]\u003e GetAllAsync() { return await _cache.GetOrAddAsync( \"AllBooksName\", async () =\u003e await _repository.Select(b =\u003e b.Name).ToArrayAsync(), () =\u003e new DistributedCacheEntryOptions { AbsoluteExpiration = DateTimeOffset.Now.AddHours(1) } ); } } 修改BookAppService实现GetAllAsyncAPI接口： public class BookController : AbpController { ... [HttpGet(\"all\")] public Task\u003cstring[]\u003e GetAllAsync() { return _service.GetAllAsync(); } } F5以调试方式运行，即可调用实现了缓存功能的GetAllAsync接口。 这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。 众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于模块化的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:2","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"上手难度及易用性 学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。 对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。 如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是模块化及依赖注入的观点，当我们将入门的重点放在模块化和依赖注入上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。 至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现模块化的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的模块化给我们提供了轻易切换到微服务方案的能力；依赖注入系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:3:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"总结 在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。 项目示例代码将托管在Github中。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:4:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"致谢 感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:5:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"}]