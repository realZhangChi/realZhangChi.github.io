[{"categories":["maui"],"content":"在 Maui 中基于 GraphicsView 视图，通过实现 IDrawable 来绘制自定义组件，并定义 Event 及 Command","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"在这篇文章中，将为 MagicButton 定义 Clicked 事件及 Command，并调用事件和命令来增加计数值。 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:0:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"先决条件 阅读在 Maui 中自绘组件1：绘制 阅读在 Maui 中自绘组件2：可绑定属性 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:1:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"事件 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:2:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"定义事件 在 GraphicsView 中，定义了 EndInteraction 事件，当 GraphicsView 被按下并放开之后触发。要在 MagicButton 中实现点击，只需要在 MagicButton 中定义 Clicked 事件，并在 EndInteraction 事件处理程序中触发 Clicked 即可。 编辑 MagicButton，定义 Clicked 事件： public event EventHandler Clicked; 定义 OnEndInteraction 方法来订阅 EndInteraction 事件，并在方法中触发 Clicked 事件： public MagicButton() { Drawable = new MagicButtonDrawable(); EndInteraction += OnEndInteraction; } private void OnEndInteraction(object sender, TouchEventArgs e) { Clicked?.Invoke(sender, e); } ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:3:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"订阅事件 修改 MainPage.xaml 中的 MagicButton，设置 Clicked 事件处理程序： \u003ccomponents:MagicButton 省略了其他属性设置...... x:Name=\"MagicButton\" Text=\"Click me\" Clicked=\"MagicButton_OnClicked\"\u003e\u003c/components:MagicButton\u003e 修改 MainPage.xaml.cs，在 MagicButton_OnClicked 方法中处理点击事件： private int _magicButtonCount = 0; private void MagicButton_OnClicked(object sender, EventArgs e) { _magicButtonCount++; MagicButton.Text = _magicButtonCount == 1 ? $\"Clicked {_magicButtonCount} time\" : $\"Clicked {_magicButtonCount} times\"; } 运行并点击 MagicButton，效果如下： Using Event ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:3:1","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"命令 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:4:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"定义命令 在 MagicButton 中定义 ICommand 类型的可绑定属性，命名为 Command；定义 object 类型的命令参数可绑定属性，命名为 CommandParameter: public static BindableProperty CommandProperty = BindableProperty.Create( nameof(Command), typeof(ICommand), typeof(MagicButton)); public ICommand Command { get =\u003e (ICommand)GetValue(CommandProperty); set =\u003e SetValue(CommandProperty, value); } public static BindableProperty CommandParameterProperty = BindableProperty.Create( nameof(CommandParameter), typeof(object), typeof(MagicButton)); public object CommandParameter { get =\u003e GetValue(CommandParameterProperty); set =\u003e SetValue(CommandParameterProperty, value); } 修改 OnEndInteraction 方法，执行 Command 命令： private void OnEndInteraction(object sender, TouchEventArgs e) { Clicked?.Invoke(sender, e); Command?.Execute(CommandParameter); } ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:4:1","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"使用 ViewModel 在项目根目录下，创建 ViewModels 文件夹，并在其中创建 MainViewModel。在 MainViewModel 中定义 ClickedCount 属性用于 MagicButton 文本显示计数值，定义 Command 来增加 ClickedCount 计数值： public class MainViewModel : INotifyPropertyChanged { private int _clickedCount; public int ClickedCount { set =\u003e SetField(ref _clickedCount, value, nameof(ClickedCount)); get =\u003e _clickedCount; } public ICommand Command { get; set; } public MainViewModel() { Command = new Command(() =\u003e { ClickedCount++; }); } public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } protected bool SetField\u003cT\u003e(ref T field, T value, [CallerMemberName] string propertyName = null) { if (EqualityComparer\u003cT\u003e.Default.Equals(field, value)) return false; field = value; OnPropertyChanged(propertyName); return true; } } 更改 MainPage.xaml.cs 在构造函数中将 BindingContext 设为 MainViewModel 的实例： public MainPage() { InitializeComponent(); BindingContext = new MainViewModel(); } 更改 MainPage.xaml 中的 MagicButton，删除 Clicked 事件，并绑定 Text 及 Command； \u003ccomponents:MagicButton 省略了其他属性设置...... x:Name=\"MagicButton\" x:DataType=\"viewModels:MainViewModel\" Text=\"{Binding ClickedCount}\" Command=\"{Binding Command}\"\u003e\u003c/components:MagicButton\u003e 运行并点击按钮，效果如下： Using Command ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:4:2","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"推荐内容 Data binding and MVVM 如何在Maui中使用依赖注入 如何在Maui中使用Autofac 如何在 Maui 中全局处理异常 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:5:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-07","objectID":"/posts/custom-component-in-maui-3/:6:0","tags":["maui"],"title":"在 Maui 中自绘组件3：事件与命令","uri":"/posts/custom-component-in-maui-3/"},{"categories":["maui"],"content":"在 Maui 中基于 GraphicsView 视图，通过实现 IDrawable 来绘制自定义组件，并为自定义组件设置可绑定属性","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"在这篇文章中，将为 MagicButton 添加可绑定属性，并根据可绑定属性进行绘制。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:0:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"先决条件 阅读在 Maui 中自绘组件1：绘制 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:1:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"更新 MagicButtonDrawable 在 MagicButtonDrawable 中，为绘制时所需的颜色、字体大小等创建属性。 public Color StrokeColor { get; set; } public float StrokeThickness { get; set; } public Color BackgroundColor { get; set; } public int FontSize { get; set; } public Color FontColor { get; set; } public string Text { get; set; } 更新 DrawBackground 等方法，依据上述属性值进行绘制。 // 以 DrawBackground 为例，其他方法同理 public void DrawBackground(ICanvas canvas, RectF dirtyRect) { canvas.SaveState(); // 使用 BackgroundColor 属性 canvas.SetFillPaint(new SolidPaint(BackgroundColor), dirtyRect); // 使用 StrokeThickness 属性 var x = dirtyRect.X + StrokeThickness; var y = dirtyRect.Y + StrokeThickness; var width = dirtyRect.Width - StrokeThickness; var height = dirtyRect.Height - StrokeThickness; canvas.FillRoundedRectangle(x, y, width, height, height / 2); canvas.RestoreState(); } ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:2:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"定义可绑定属性 为 MagicButton 定义 StrokeColor、StrokeThickness、FontSize、FontColor、Text等可绑定属性。在 GraphicsView 中已定义 BackgroundColor 可绑定属性，无需重复定义。 // 以 StrokeColor 可绑定属性为例，其他方法同理 public static BindableProperty StrokeColorProperty = BindableProperty.Create( nameof(StrokeColor), typeof(Color), typeof(MagicButton), null, propertyChanged: (bindable, value, newValue) =\u003e { if (bindable is MagicButton magicButton) { // TODO：处理属性值变更，进行重绘 } }); public Color StrokeColor { get =\u003e (Color)GetValue(FontColorProperty); set =\u003e SetValue(FontColorProperty, value); } 定义 UpdateStrokeColor 等方法，在属性值变更后，更新 MagicButtonDrawable 中相应属性值，并进行重绘。 // 以 UpdateStrokeColor 为例，其他同理 public void UpdateStrokeColor() { if (Drawable is not MagicButtonDrawable drawable) { return; } if (StrokeColor is null) { return; } // 更新 MagicButtonDrawable 中 StrokeColor 值 drawable.StrokeColor = StrokeColor; // 通知并进行重绘 Invalidate(); } 更新 StrokeColorProperty 等属性中的 propertyChanged，调用相应方法以在属性值变更时更新 MagicButtonDrawable 并重绘。 public static BindableProperty StrokeColorProperty = BindableProperty.Create( nameof(StrokeColor), typeof(Color), typeof(MagicButton), null, propertyChanged: (bindable, value, newValue) =\u003e { if (bindable is MagicButton magicButton) { magicButton.UpdateStrokeColor(); } }); ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:3:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"设置 MagicButton 属性值 更新 MainPage.xaml，修改 MagicButton 的使用，设置属性，并将 Text 属性绑定到 CounterBtn 中的 Text，来查看绑定效果。 \u003c!--使用自定义的 MagicButton--\u003e \u003ccomponents:MagicButton HeightRequest=\"60\" WidthRequest=\"200\" BackgroundColor=\"Blue\" StrokeColor=\"{StaticResource Black}\" StrokeThickness=\"3\" FontColor=\"{StaticResource Cyan300Accent}\" FontSize=\"25\" BindingContext=\"{x:Reference CounterBtn}\" Text=\"{Binding Text}\"\u003e\u003c/components:MagicButton\u003e \u003cButton x:Name=\"CounterBtn\" Text=\"Click me\" SemanticProperties.Hint=\"Counts the number of times you click\" Clicked=\"OnCounterClicked\" HorizontalOptions=\"Center\" /\u003e 运行并点击 CounterBtn， 效果如下： Custom Button ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:4:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"推荐内容 在 Maui 中自绘组件1：绘制 如何在Maui中使用Autofac 在 Maui 中使用 DialogX 展示消息对话框 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:5:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-2/:6:0","tags":["maui"],"title":"在 Maui 中自绘组件2：可绑定属性","uri":"/posts/custom-component-in-maui-2/"},{"categories":["maui"],"content":"在 Maui 中基于 GraphicsView 视图，通过实现 IDrawable 来绘制自定义组件","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"在这篇文章中，将自定义一个简单的按钮组件，绘制边框、背景、文字元素。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:0:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"GraphicsView Maui 中提供了 GraphicsView 视图，可通过继承 GraphicsView 视图来自定义组件。 GraphicsView 中定义了类型为 IDrawable 的属性，在渲染时，将调用 IDrawable 中的 Draw 方法来绘制组件。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:1:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"创建 MagicButtonDrawable 新建一个空的 Maui 项目，在项目根目录下创建 Components 文件夹，在其中创建 MagicButtonDrawable 类，并继承 IDrawable。MagicButtonDrawable 将负责自定义组件的绘制。 public class MagicButtonDrawable : IDrawable { public void Draw(ICanvas canvas, RectF dirtyRect) { } } ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:2:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"绘制边框 定义方法 DrawStroke 来绘制边框： public void DrawStroke(ICanvas canvas, RectF dirtyRect) { canvas.SaveState(); canvas.SetFillPaint(new SolidPaint(Brush.LightBlue.Color), dirtyRect); canvas.FillRoundedRectangle(dirtyRect.X, dirtyRect.Y, dirtyRect.Width, dirtyRect.Height, dirtyRect.Height / 2); canvas.RestoreState(); } 在此方法中调用了 ICanvas 的 FillRoundedRectangle 方法，绘制了一个填充色为 LightBlue 的圆角矩形。下一步将在此矩形之上，再绘制一个宽高小于此图案的不同填充色的圆角矩形，来实现边框的效果。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:2:1","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"绘制背景 定义方法 DrawBackground 来绘制背景： public void DrawBackground(ICanvas canvas, RectF dirtyRect) { canvas.SaveState(); canvas.SetFillPaint(new SolidPaint(Brush.Blue.Color), dirtyRect); var strokeThickness = 3; var x = dirtyRect.X + strokeThickness; var y = dirtyRect.Y + strokeThickness; var width = dirtyRect.Width - strokeThickness * 2; var height = dirtyRect.Height - strokeThickness * 2; canvas.FillRoundedRectangle(x, y, width, height, height / 2); canvas.RestoreState(); } 将边框厚度设为3，那么将绘制起始点的 X、Y坐标都加上边框的宽度， 并将宽度和高度都减去两个边框的厚度，来进行绘制，即可得到底层一个大的圆角矩形，其上一个略小的圆角矩形，从而实现边框的效果。 技巧 dirtyRect 的 X 和 Y 为绘制区域的左上角坐标，在 canvas 上进行绘制将根据 dirtyRect 的 X 和 Y 从左上角开始绘制。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:2:2","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"绘制文本 定义方法 DrawText 来绘制按钮中的文本内容： public void DrawText(ICanvas canvas, RectF dirtyRect) { canvas.SaveState(); canvas.FontColor = Brush.White.Color; canvas.FontSize = 16; canvas.DrawString(\"Magic Button\", dirtyRect.X, dirtyRect.Y, dirtyRect.Width, dirtyRect.Height, HorizontalAlignment.Center, VerticalAlignment.Center); canvas.RestoreState(); } ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:2:3","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"创建 MagicButton 在 Components 文件夹中创建 MagicButton 类，并继承 GraphicsView。通过构造函数将 Drawable 属性设置为 MagicButtonDrawable 的实例。 public class MagicButton : GraphicsView { public MagicButton() { Drawable = new MagicButtonDrawable(); } } ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:3:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"使用 MagicButton 修改 MainPage.xaml 引用 MagicButton 名称空间，并添加 MagicButton 组件： \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cContentPage xmlns=\"http://schemas.microsoft.com/dotnet/2021/maui\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:components=\"clr-namespace:YOUR_MAGICBUTTON_NAMESPACE\" x:Class=\"YOUR_ROOT_NAMESAPCE.MainPage\"\u003e \u003cScrollView\u003e \u003cVerticalStackLayout Spacing=\"25\" Padding=\"30,0\" VerticalOptions=\"Center\"\u003e \u003c!-- ...... --\u003e \u003c!--使用自定义的 MagicButton--\u003e \u003ccomponents:MagicButton HeightRequest=\"50\" WidthRequest=\"150\"\u003e\u003c/components:MagicButton\u003e \u003cButton x:Name=\"CounterBtn\" Text=\"Click me\" SemanticProperties.Hint=\"Counts the number of times you click\" Clicked=\"OnCounterClicked\" HorizontalOptions=\"Center\" /\u003e \u003c/VerticalStackLayout\u003e \u003c/ScrollView\u003e \u003c/ContentPage\u003e 效果如下： Custom Button ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:4:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"推荐阅读 在 Maui 中自绘组件2：可绑定属性 如何在 Maui 中全局处理异常 在 Maui 中使用 DialogX 展示底部菜单 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:5:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-06","objectID":"/posts/custom-component-in-maui-1/:6:0","tags":["maui"],"title":"在 Maui 中自绘组件1：绘制","uri":"/posts/custom-component-in-maui-1/"},{"categories":["maui"],"content":"在 Maui 项目中引入 DialogX 原生安卓的绑定类库，显示对话框、菜单、提示效果、输入框","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"DialogX Android Sdk DialogX 是一个开源的 Android 对话框组件库，方便易用，扩展性强，轻松实现各种对话框、菜单和提示效果。 DialogX 项目在 github 上开源，地址：https://github.com/kongzue/DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:1:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"DialogX 绑定库 在 MauiBinding 项目中已为 DialogX 创建好了绑定类库，并可在 Nuget 下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.Android.DialogX 即可使用 DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:2:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"初始化 创建一个新的 Maui 项目，并添加Nuget包 Chi.MauiBinding.Android.DialogX 引用。 打开并编辑 DialogXMaui/Platforms/Android/MainApplication.cs, 重写 OnCreate 方法，对 DialogX 进行初始化。 public override void OnCreate() { base.OnCreate(); Com.Kongzue.Dialogx.DialogX.Init(this); } ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:3:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"展示底部菜单 通过查阅 DialogX Wiki 可知，调用 BottomDialog.Show() 可弹出底部菜单。 打开并编辑 MainPage.xaml.cs，修改 OnCounterClicked 方法如下： private void OnCounterClicked(object sender, EventArgs e) { BottomMenu.Show(\"菜单\", new[] { \"菜单1\", \"菜单2\", \"菜单3\" }); } 运行项目并点击按钮，将弹出底部菜单。 BottomMenu in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:4:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"菜单项选中回调 根据 DialogX Wiki 所描述，可通过 SetOnMenuItemClickListener() 方法来设置菜单项点击的回调处理。 在 Visual Studio 中转到 SetOnMenuItemClickListener 方法的定义，可以发现 SetOnMenuItemClickListener 方法接受类型为 IOnMenuItemClickListener 的参数。在 C# 中不支持匿名类的创建，因此需要先创建一个继承 IOnMenuItemClickListener 接口的类，在调用 SetOnMenuItemClickListener 的时候实例化并传入。 创建名为 MenuItemClickListener 的类： public class MenuItemClickListener : Java.Lang.Object, IOnMenuItemClickListener { public Func\u003cBottomMenu, string, int, bool\u003e OnMenuItemClick; public bool OnClick(Object p0, ICharSequence p1, int p2) { if (p0 is BottomMenu bm) { return OnMenuItemClick?.Invoke(bm, p1.ToString(), p2) ?? false; } return false; } } OnClick 是定义在 IOnMenuItemClickListener 接口中的方法，在点击某个菜单项时被调用。当 OnClick 被调用时，将执行 OnMenuItemClick。OnMenuItemClick 在实例化 MenuItemClickListener 时赋值。 修改 OnCounterClicked 方法，设置菜单项点击回调，并在回调方法中调用 DialogX 的 PopTip 弹出文本提示，展示选中菜单名称及其索引： private void OnCounterClicked(object sender, EventArgs e) { BottomMenu.Show(\"菜单\", new[] { \"菜单1\", \"菜单2\", \"菜单3\" })? .SetOnMenuItemClickListener(new MenuItemClickListener() { OnMenuItemClick = (menu, menuName, menuIndex) =\u003e { PopTip.Show($\"{menuName} has been clicked! index: {menuIndex}\"); return false; } }); } 技巧 回调函数返回false时，底部菜单关闭；回调函数返回true时，底部菜单将不会关闭。 运行项目并点击按钮，点击底部菜单中的某一菜单项后，将关闭底部菜单并弹出 PopTip 提示，展示选中菜单名称及其索引。 BottomMenu in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:4:1","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"推荐内容 在 Maui 中使用 DialogX 展示输入对话框 在 Maui 中使用 DialogX 展示消息对话框 请查阅 DialogX Wiki 获取主题设置、自定义布局、自定义动画等更多用法。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:5:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-3/:6:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示底部菜单","uri":"/posts/use-dialogx-in-maui-3/"},{"categories":["maui"],"content":"在 Maui 项目中引入 DialogX 原生安卓的绑定类库，显示对话框、菜单、提示效果、输入框","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"DialogX Android Sdk DialogX 是一个开源的 Android 对话框组件库，方便易用，扩展性强，轻松实现各种对话框、菜单和提示效果。 DialogX 项目在 github 上开源，地址：https://github.com/kongzue/DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:1:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"DialogX 绑定库 在 MauiBinding 项目中已为 DialogX 创建好了绑定类库，并可在 Nuget 下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.Android.DialogX 即可使用 DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:2:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"初始化 创建一个新的 Maui 项目，并添加Nuget包 Chi.MauiBinding.Android.DialogX 引用。 打开并编辑 DialogXMaui/Platforms/Android/MainApplication.cs, 重写 OnCreate 方法，对 DialogX 进行初始化。 public override void OnCreate() { base.OnCreate(); Com.Kongzue.Dialogx.DialogX.Init(this); } ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:3:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"展示输入对话框 通过查阅 DialogX Wiki 可知，实例化 InputDialog 并调用 Show() 可弹出输入对话框。 打开并编辑 MainPage.xaml.cs，修改 OnCounterClicked 方法如下： private void OnCounterClicked(object sender, EventArgs e) { var input = new InputDialog(\"Hi\", null, \"确定\"); input.Show(); } 运行项目并点击按钮，将弹出包含一个文本输入的对话框。 InputDialog in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:4:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"确认回调 根据 DialogX Wiki 所描述，可通过 SetOkButtonClickListener() 方法来设置确认按钮的回调处理。 在 Visual Studio 中转到 SetOkButton 方法的定义，可以发现 SetOkButtonClickListener 方法接受类型为 IOnInputDialogButtonClickListener 的参数。在 C# 中不支持匿名类的创建，因此需要先创建一个继承 IOnInputDialogButtonClickListener 接口的类，在调用 SetOkButtonClickListener 的时候实例化并传入。 创建名为 InputOkClickListener 的类： public class InputOkClickListener : Java.Lang.Object, IOnInputDialogButtonClickListener { public Func\u003cInputDialog, View, string, bool\u003e OnOkButtonClicked; public bool OnClick(Object p0, View p1, string p2) { if (p0 is InputDialog id) { return OnOkButtonClicked(id, p1, p2); } return false; } } OnClick 是定义在 IOnInputDialogButtonClickListener 接口中的方法，在点击确认按钮时被调用。当 OnClick 被调用时，将执行 OnOkButtonClicked。OnOkButtonClicked 在实例化 OkClickListener 时赋值。 修改 OnCounterClicked 方法，设置按钮回调，并在回调方法中调用 DialogX 的 PopTip 弹出文本提示，将输入至对话框中的内容显示出来： private void OnCounterClicked(object sender, EventArgs e) { var input = new InputDialog(\"Hi\", null, \"确定\"); input.Show(); input.SetOkButtonClickListener(new InputOkClickListener() { OnOkButtonClicked = (dialog, view, arg3) =\u003e { PopTip.Show(arg3); return false; } }); } 技巧 回调函数返回false时，输入对话框关闭；回调函数返回true时，输入对话框将不会关闭。 运行项目并点击按钮，在输入框内输入一些内容，点击输入对话框的“确定”按钮后，关闭输入对话框并弹出 PopTip 提示。PopTip 将把输入到对话框中的内容展示出来。 InputDialog in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:4:1","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"推荐内容 请查阅 DialogX Wiki 获取主题设置、自定义布局、自定义动画等更多用法。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:5:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui-2/:6:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示输入对话框","uri":"/posts/use-dialogx-in-maui-2/"},{"categories":["maui"],"content":"在 Maui 项目中引入 DialogX 原生安卓的绑定类库，显示对话框、菜单、提示效果、输入框","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"DialogX Android Sdk DialogX 是一个开源的 Android 对话框组件库，方便易用，扩展性强，轻松实现各种对话框、菜单和提示效果。 DialogX 项目在 github 上开源，地址：https://github.com/kongzue/DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:1:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"DialogX 绑定库 在 MauiBinding 项目中已为 DialogX 创建好了绑定类库，并可在 Nuget 下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.Android.DialogX 即可使用 DialogX。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:2:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"初始化 创建一个新的 Maui 项目，并添加Nuget包 Chi.MauiBinding.Android.DialogX 引用。 打开并编辑 DialogXMaui/Platforms/Android/MainApplication.cs, 重写 OnCreate 方法，对 DialogX 进行初始化。 public override void OnCreate() { base.OnCreate(); Com.Kongzue.Dialogx.DialogX.Init(this); } ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:3:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"展示消息对话框 通过查阅 DialogX Wiki 可知，调用 MessageDialog.Show() 可弹出消息对话框。 打开并编辑 MainPage.xaml.cs，修改 OnCounterClicked 方法如下： private void OnCounterClicked(object sender, EventArgs e) { MessageDialog.Show(\"Hi\", \"Maui\", \"确定\"); } 运行项目并点击按钮，将弹出消息对话框。 MessageDialog in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:4:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"确认回调 根据 DialogX Wiki 所描述，可通过 MessageDialog.Show().SetOkButton() 方法来设置确认按钮的回调处理。 在 Visual Studio 中转到 SetOkButton 方法的定义，可以发现 SetOkButton 方法接受类型为 IOnDialogButtonClickListener 的参数。在 C# 中不支持匿名类的创建，因此需要先创建一个继承 IOnDialogButtonClickListener 接口的类，在调用 SetOkButton 的时候实例化并传入。 创建名为 OkClickListener 的类： public class OkClickListener : Java.Lang.Object, IOnDialogButtonClickListener { public Func\u003cMessageDialog, View, bool\u003e OnOkButtonClicked; public bool OnClick(Object p0, View p1) { if (p0 is MessageDialog md) { return OnOkButtonClicked?.Invoke(md, p1) ?? false; } return false; } } OnClick 是定义在 IOnDialogButtonClickListener 接口中的方法，在点击确认按钮时被调用。当 OnClick 被调用时，将执行 OnOkButtonClicked。OnOkButtonClicked 在实例化 OkClickListener 时赋值。 修改 OnCounterClicked 方法，设置按钮回调，并在回调方法中调用 DialogX 的 PopTip 弹出文本提示： private void OnCounterClicked(object sender, EventArgs e) { MessageDialog.Show(\"Hi\", \"Maui\", \"确定\") .SetOkButton(new OkClickListener() { OnOkButtonClicked = (dialog, view) =\u003e { PopTip.Show(\"Hello! Ok Button has been clicked!\"); return false; } }); } 技巧 回调函数返回false时，消息对话框关闭；回调函数返回true时，消息对话框将不会关闭。 运行项目并点击按钮，点击消息对话框的“确定”按钮后，将关闭消息对话框并弹出 PopTip 提示。 MessageDialog in maui ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:4:1","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"推荐内容 在 Maui 中使用 DialogX 展示输入对话框 在 Maui 中使用 DialogX 展示底部菜单 在 Maui 中自绘组件1：绘制 请查阅 DialogX Wiki 获取主题设置、自定义布局、自定义动画等更多用法。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:5:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-02","objectID":"/posts/use-dialogx-in-maui/:6:0","tags":["maui","binding library"],"title":"在 Maui 中使用 DialogX 展示消息对话框","uri":"/posts/use-dialogx-in-maui/"},{"categories":["maui"],"content":"在 Maui 项目中引入 EasyFloat 原生安卓的绑定类库，来显示自定义浮窗","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"EasyFloat Android Sdk EasyFloat 是一个开源的 Android 浮窗框架，支持可拖拽悬浮窗口，支持页面过滤、自定义动画，可设置单页面浮窗、前台浮窗、全局浮窗，浮窗权限按需自动申请等多种功能 。 EasyFloat 项目在 github 上开源，地址：https://github.com/princekin-f/EasyFloat. ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:1:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"EasyFloat 绑定库 在 MauiBinding 项目中已为 EasyFloat 创建好了绑定类库，并可在 Nuget 上下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.EasyFloat.Android 即可使用 EasyFloat。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:2:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"如何使用 根据 EasyFloat 文档描述，定义了以下方法用于显示浮窗： Com.Lzf.Easyfloat.EasyFloat .With(your_android_app_activity) .SetLayout(your_float_view) .Show(); 其中 With 方法接收类型为 Android.Content.Context 的安卓平台 Activity，可通过安装 Nuget 包 Microsoft.Maui.Essentials 并调用 Microsoft.Maui.ApplicationModel.Platform.CurrentActivity 获取当前 Activity。 SetLayout 方法接收安卓平台的 Android.Views.View，此参数即为要显示的浮窗。在 Maui 中，可以创建 Maui 的 ContentView，并调用其扩展方法 ToPlatform 将 Maui 的 ContentView 转换为安卓平台的 Android.Views.View。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:3:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"项目实践 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:4:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"初始化项目 创建一个新的 Maui 项目，并添加对Nuget包 Chi.MauiBinding.EasyFloat.Android、Microsoft.Maui.Essentials 引用。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:4:1","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"创建浮窗 在项目中新建一个 ContentView 命名为 FloatView，修改 XAML 代码调整样式： \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cContentView xmlns=\"http://schemas.microsoft.com/dotnet/2021/maui\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"YOUR_NAMESPACE_TO_FLOAT_VIEW_CLASS.FloatView\"\u003e \u003cBorder HeightRequest=\"50\" WidthRequest=\"200\" BackgroundColor=\"{StaticResource Cyan300Accent}\"\u003e \u003cBorder.StrokeShape\u003e \u003cRoundRectangle CornerRadius=\"25\" StrokeThickness=\"0\"/\u003e \u003c/Border.StrokeShape\u003e \u003cVerticalStackLayout VerticalOptions=\"Center\"\u003e \u003cLabel Text=\"Welcome to .NET MAUI!\" VerticalOptions=\"Center\" HorizontalOptions=\"Center\" /\u003e \u003c/VerticalStackLayout\u003e \u003c/Border\u003e \u003c/ContentView\u003e 替换代码 替换上述代码中的 YOUR_NAMESPACE_TO_FLOAT_VIEW_CLASS 为你创建的 FloatView 所在名称空间。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:4:2","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"显示浮窗 更改 MainPage.xaml.cs 中的代码，加入显示浮窗的代码： private bool _isFloatViewShow = false; private const string FloatViewTag = \"FloatView\"; private void OnCounterClicked(object sender, EventArgs e) { #if ANDROID if (!_isFloatViewShow \u0026\u0026 Microsoft.Maui.ApplicationModel.Platform.CurrentActivity != null \u0026\u0026 Application.Current?.Handler?.MauiContext != null) { EasyFloat .With(Microsoft.Maui.ApplicationModel.Platform.CurrentActivity) .SetTag(FloatViewTag) .SetLayout(new FloatView().ToPlatform(Application.Current.Handler.MauiContext)) .SetLocation(250, 1000) .SetDragEnable(true) .Show(); _isFloatViewShow = true; } else { EasyFloat.Dismiss(FloatViewTag); _isFloatViewShow = false; } #endif } 运行项目并点击按钮，即可弹出浮窗。 EasyFloat in maui ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:4:3","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"推荐内容 关于 EasyFloat 的更多用法，请参考 EasyFloat 文档。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:5:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-03-01","objectID":"/posts/use-easy-float-in-maui/:6:0","tags":["maui","binding library"],"title":"如何在 Maui 中使用 EasyFloat 显示浮窗","uri":"/posts/use-easy-float-in-maui/"},{"categories":["maui"],"content":"在 Maui 中，结合 AOP 等技术，全局捕获 ViewModel 中异步方法产生的异常，并弹出 Toast 提示。","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"在“如何在 Maui 中全局处理异常”一文中介绍了通过 Autofac 动态代理，对 ViewModel 进行拦截，全局捕获 ViewModel 中的异常，并使用 Toaster 弹出异常消息提示。然而，Autofac 中的动态代理只支持对同步方法进行拦截。本文将继续介绍如何实现对异步方法的代理拦截。 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:0:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"先决条件 如何在 Maui 中全局处理异常 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:1:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"Castle.Core.AsyncInterceptor Castle.Core.AsyncInterceptor 是一个简化异步方法拦截的库，通过引入 Castle.Core.AsyncInterceptor ，可以在 Maui 中轻松实现对异步方法的拦截。 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:2:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"更新项目 调整在“如何在 Maui 中全局处理异常”中创建的项目，更改ViewModel中的 RaiseException 方法为异步的 RaiseExceptionAsync 方法，并返回 Task。 public virtual Task RaiseExceptionAsync() { throw new Exception(\"An Exception has been throw!\"); } 更改 MainPage.xaml.cs中的 OnCounterClicked 方法，为方法签名加入 async 关键字，将 RaiseException 方法调用改为异步并等待。 private async void OnCounterClicked(object sender, EventArgs e) { if (BindingContext is MainViewModel vm) { await vm.RaiseExceptionAsync(); } } ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:3:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"引入 Castle.Core.AsyncInterceptor 通过 CLI 或 Nuget 包管理器添加对 Castle.Core.AsyncInterceptor 的引用。 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:4:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"实现异步拦截器 Castle.Core.AsyncInterceptor 定义了 IAsyncInterceptor 接口，创建继承 IAsyncInterceptor 接口的类即可实现异步拦截器。 在 ViewModels/Interceptors 路径下，创建类 ExceptionHandleAsyncInterceptor，继承 IAsyncInterceptor 接口并实现接口中定义的方法。 public class ExceptionHandleAsyncInterceptor : IAsyncInterceptor { public void InterceptSynchronous(IInvocation invocation) { try { invocation.Proceed(); } catch (Exception e) { #if ANDROID Com.Hjq.Toast.Toaster.Show(e.Message); #endif } } public void InterceptAsynchronous(IInvocation invocation) { invocation.ReturnValue = InternalInterceptAsynchronous(invocation); } private async Task InternalInterceptAsynchronous(IInvocation invocation) { try { invocation.Proceed(); var task = (Task)invocation.ReturnValue; await task; } catch (Exception e) { #if ANDROID Com.Hjq.Toast.Toaster.Show(e.Message); #endif } } public void InterceptAsynchronous\u003cTResult\u003e(IInvocation invocation) { invocation.ReturnValue = InternalInterceptAsynchronous\u003cTResult\u003e(invocation); } private async Task\u003cTResult?\u003e InternalInterceptAsynchronous\u003cTResult\u003e(IInvocation invocation) { try { invocation.Proceed(); var task = (Task\u003cTResult?\u003e)invocation.ReturnValue; TResult? result = await task; return result; } catch (Exception e) { #if ANDROID Com.Hjq.Toast.Toaster.Show(e.Message); #endif return default; } } } IAsyncInterceptor 中定义了 InterceptSynchronous、InterceptAsynchronous、InterceptAsynchronous\u003cTResult\u003e 三个方法。InterceptSynchronous 用于实现对同步方法的拦截，InterceptAsynchronous 用于实现对返回值为 Task 的异步方法的拦截，InterceptAsynchronous\u003cTResult\u003e 用于实现对返回值为泛型的 Task\u003cTResult\u003e 异步方法的拦截。关于 Castle.Core.AsyncInterceptor 的更多用法，参见其 Github 仓库。 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:5:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"注册使用异步拦截器 在 MainProgram.cs 文件中注册新建的异步拦截器。 containerBuilder.RegisterType\u003cExceptionHandleAsyncInterceptor\u003e(); 技巧 不要将 MainViewModel 服务注册代码中的 InterceptedBy 方法参数更改为 typeof(ExceptionHandleAsyncInterceptor)。 对 MainViewModel 的拦截行为仍将使用基于 IInterceptor 的拦截器。对于异步方法的支持将通过在基于 IInterceptor 的拦截器中来调用异步拦截器来实现。 修改原来同步方法使用的 ExceptionHandleInterceptor 拦截器，将异步拦截器注入其中，并将对方法的拦截操作交给异步拦截器。 public class ExceptionHandleInterceptor : IInterceptor { private readonly ExceptionHandleAsyncInterceptor _asyncInterceptor; public ExceptionHandleInterceptor(ExceptionHandleAsyncInterceptor asyncInterceptor) { _asyncInterceptor = asyncInterceptor; } public void Intercept(IInvocation invocation) { _asyncInterceptor.ToInterceptor().Intercept(invocation); } } ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:6:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"效果测试 启动项目并点击页面上的按钮，将会看到异常被捕获并通过 Toaster 展示出来。 异常消息提示 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:7:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"参考内容 如何在Maui中使用Autofac 在 Maui Android 中使用 Toaster 如何在 Maui 中全局处理异常 Type Interceptors — Autofac 6.0.0 documentation Castle.Core.AsyncInterceptor ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:8:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-02-27","objectID":"/posts/handle-exception-of-async-method-in-maui/:9:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常（异步方法）","uri":"/posts/handle-exception-of-async-method-in-maui/"},{"categories":["maui"],"content":"在 Maui 中，结合 AOP 等技术，全局捕获 ViewModel 中产生的异常，并弹出 Toast 提示。","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"在“如何在Maui中使用Autofac”一文中介绍了，如何在 Maui 中使用 Autofac 依赖注入容器。使用 Autofac ，可以实现面向切面编程（AOP）等。在 Maui 中进行全局捕获并处理异常，可以利用 AOP 来实现。 这篇文章通过一个示例程序来展示了如何在 Maui 程序中集成 Autofac ，并基于 AOP 技术来实现全局异常处理功能。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:0:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"引用相关 Nuget 包 新建 Maui 项目，并添加 Autofac.Extensions.DependencyInjection、Autofac.Extras.DynamicProxy Nuget 包引用。 Autofac.Extensions.DependencyInjection 是将 Autofac 集成到 Maui 中需要使用的包，Autofac.Extras.DynamicProxy 使注册到 Autofac 容器中的服务能够被拦截，以实现 AOP。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:1:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"创建 ViewModel 在项目根目录下，创建 ViewModels 文件夹，并在其中创建 MainViewModel.cs。在 ViewModel 中定义名为 RaiseException 的方法，来模拟引发异常。 public class MainViewModel { public virtual void RaiseException() { throw new Exception(\"An Exception has been throw!\"); } } 虚方法 Autofac 对类进行拦截时，将会创建一个子类并继承被拦截的类，从而实现拦截。因此被拦截类中的方法必须定义为 virtual，以便子类对其重写。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:2:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"创建拦截器 定义拦截器，只需定义一个类，并使其继承 Castle.DynamicProxy.IInterceptor 接口即可。 在 ViewModels 文件夹中创建 Interceptors 文件夹，并在其中创建 ExceptionHandleInterceptor.cs。 public class ExceptionHandleInterceptor : IInterceptor { public void Intercept(IInvocation invocation) { try { invocation.Proceed(); } catch (Exception e) { // TODO: Handle exception } } } IInterceptor 接口中定义了 Intercept 方法。在 Intercept 方法中通过 try 代码块将被拦截方法的调用包括起来，来捕获被拦截服务的方法调用异常，在 catch 代码块中对异常进行处理。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:3:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"集成 Toaster 展示异常消息 通过在界面弹出 Toast 的方式，可以实现异常消息的用户友好提示。在 Maui Android 中集成显示 Toast 提示框的详细内容，参见“在 Maui Android 中使用 Toaster”。 集成 Toaster 后，在 ExceptionHandleInterceptor 的 Intercept 方法的 catch 代码块调用 Toaster 并显示异常消息。 public class ExceptionHandleInterceptor : IInterceptor { public void Intercept(IInvocation invocation) { try { invocation.Proceed(); } catch (Exception e) { // 调用 Toaster 并显示异常消息 #if ANDROID Com.Hjq.Toast.Toaster.Show(e.Message); #endif } } } ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:3:1","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"注册服务及拦截器 编辑 MauiProgram.cs 文件，使 Maui 应用程序的依赖注入系统使用 Autofac 容器，并将服务及拦截器注册到容器中。关于更多在 Maui 项目中集成 Autofac 的内容，请参考“如何在Maui中使用Autofac”。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); // ...... builder.ConfigureContainer(new AutofacServiceProviderFactory((containerBuilder) =\u003e { containerBuilder.Populate(builder.Services); // 注册拦截器 containerBuilder.RegisterType\u003cExceptionHandleInterceptor\u003e(); containerBuilder.RegisterType\u003cMainPage\u003e(); // 注册ViewModel服务 containerBuilder.RegisterType\u003cMainViewModel\u003e() // 启用基于类的拦截器 .EnableClassInterceptors() // 配置拦截器 .InterceptedBy(typeof(ExceptionHandleInterceptor)); })); return builder.Build(); } } ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:4:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"效果测试 更改 MainPage.xaml.cs 代码，将 MainViewModel 注入进去，并在 OnCounterClicked 方法中调用 ViewModel 中的 RaiseException 来模拟引发异常。 public partial class MainPage : ContentPage { public MainPage(MainViewModel vm) { InitializeComponent(); BindingContext = vm; } private void OnCounterClicked(object sender, EventArgs e) { if (BindingContext is MainViewModel vm) { vm.RaiseException(); } } } 运行并点击按钮，可以看到异常被拦截处理并且弹出 Toast 显示异常消息。 异常消息提示 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:5:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"推荐内容 如何在Maui中使用Autofac 如何在 Maui 中全局处理异常（异步方法） 在 Maui Android 中使用 Toaster Type Interceptors — Autofac 6.0.0 documentation ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:6:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:7:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"如何在 Maui 项目中使用 Toaster","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"Toaster Android Sdk Toaster 是一个开源的 Android 吐司框架，原名 ToastUtils ，已更名为 Toaster 。 Toaster 项目在 github 上开源，地址：https://github.com/getActivity/Toaster. ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:1:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"Toaster 绑定库 在 Maui 项目中使用原生 SDK 非常简单，只需要创建绑定类库即可。在 MauiBinding 项目中已为 Toaster 创建好了绑定类库，并可在 Nuget 上下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.Android.Toaster 即可使用 Toaster。 ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:2:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"使用 Toaster ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"初始化 Toaster 根据 Toaster 文档，要使用 Toaster ，首先需要进行初始化配置。 在 Maui 项目的 Platforms/Android/MainApplication.cs 文件中，重写 OnCreate 方法，并调用 Toaster.Init(this); 来初始化 Toaster，完整代码如下： // 引用 Toaster Sdk 名称空间 using Com.Hjq.Toast; [Application] public class MainApplication : MauiApplication { public MainApplication(IntPtr handle, JniHandleOwnership ownership) : base(handle, ownership) { } protected override MauiApp CreateMauiApp() =\u003e MauiProgram.CreateMauiApp(); public override void OnCreate() { base.OnCreate(); // 初始化 Toaster Toaster.Init(this); } } ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:1","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"显示 Toast 创建一个空的 Maui 项目，并编辑 MainPage.xaml.cs 文件，在 OnCounterClicked 方法中编写调用 Toaster 的代码： private void OnCounterClicked(object sender, EventArgs e) { // 调用 Toaster 并显示字符串 #if ANDROID Com.Hjq.Toast.Toaster.Show(\"Toaster in Maui\"); #endif count++; if (count == 1) CounterBtn.Text = $\"Clicked {count} time\"; else CounterBtn.Text = $\"Clicked {count} times\"; SemanticScreenReader.Announce(CounterBtn.Text); } 效果如下： Toast in maui ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:2","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"更多用法 可查看 Toaster 文档来使用 Toaster 的更多功能。 ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:4:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:5:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"在Maui中使用Autofac容器来管理对象的生命周期","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"Autofac是一个开源的控制反转容器，通过将.NET程序的控制反转容器替换为Autofac，可以实现例如属性注入、面向切面编程等功能。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:0:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"引用Autofac 从NuGet引用 Autofac.Extensions.DependencyInjection包。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:1:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"使用Autofac容器 打开MauiProgram.cs文件，在所有代码最后、return builder.Build();之前，通过ConfigureContainer来使用AutofacServiceProviderFactory来构建使用Autofac容器： public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); fonts.AddFont(\"OpenSans-Semibold.ttf\", \"OpenSansSemibold\"); }); #if DEBUG builder.Logging.AddDebug(); #endif // 添加以下代码 builder.ConfigureContainer(new AutofacServiceProviderFactory((containerBuilder) =\u003e { // Once you've registered everything in the ServiceCollection, call // Populate to bring those registrations into Autofac. This is // just like a foreach over the list of things in the collection // to add them to Autofac. containerBuilder.Populate(builder.Services); // Make your Autofac registrations. Order is important! // If you make them BEFORE you call Populate, then the // registrations in the ServiceCollection will override Autofac // registrations; if you make them AFTER Populate, the Autofac // registrations will override. You can make registrations // before or after Populate, however you choose. containerBuilder.RegisterType\u003cMainPage\u003e(); containerBuilder.RegisterType\u003cMainViewModel\u003e(); })); return builder.Build(); } 在上述代码中，通过调用Populate方法，将Maui在ServiceCollection中的服务注册，配置到了Autofac容器中，然后通过RegisterType将项目中的服务注册到Autofac容器中。 关注代码顺序 上述步骤中的代码顺序至关重要，他将影响服务在容器中的注册，详情参见Autofac文档。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:2:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"解析依赖项 通过上述步骤将依赖注入容器替换为Autofac，将不会影响在Maui中解析依赖项的方式。正如《如何在Maui中使用依赖注入》一文中所介绍的，可以通过构造函数来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:3:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"推荐内容 《如何在Maui中使用依赖注入》 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:4:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"源码获取 扫描下方二维码，关注公众号捕获异常，回复 maui 获取源码。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:5:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["Abp极简教程"],"content":"从手动创建项目CatchException开始，添加Abp应用、模块来集成Abp框架。","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp是一个基于.NET的开源应用程序框架，它遵循最佳实践和约定，根据DDD模式进行设计和开发，并提供了强大的基础设施和完整的架构。 Abp提供了项目启动模板，它依据DDD模式进行分层，并预先配置了常用的模块。启动模板中反映着领域驱动设计、最佳实践等多种概念，其中任一项都值得单独讨论。对于初学者而言，启动模板中的大量知识如潮水般瞬间涌入脑海，造成知识过载，无法聚焦当前真正要学习的知识。 本系列教程，将结合一个问答网站CatchException示例项目，从简单的.NET Web Api应用程序开始，搭建起基于Abp的Web应用程序框架，并逐步深入细节，旨在以一种缓和的学习曲线帮助初学者快速入门，理解Abp启动模板的分层项目。 关注代码 教程中会对必要的领域驱动设计概念进行简单的描述，如果在阅读本教程时对其感到困惑，那么暂时不要深入领域驱动设计的细节，请专注于代码及代码的设计思路。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"创建应用 通过VS创建一个名为CatchExceptionWeb Api应用，选择ASP.NET Core Web Api项目模板，或通过CLI执行dotnet new webapi -n CatchException。运行后将访问至Swagger页面。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"集成Abp 首先需要添加Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc Nuget包引用至项目中以集成Abp框架。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp应用 Abp框架中定义了IAbpApplication应用，这也是Abp项目的入口点，Abp应用包含了启动模块及其依赖。在项目启动时需要将Abp应用注册到依赖注入系统中去，并指定启动模块。Abp定义了AddApplication泛型扩展方法，它将Abp应用注册为单例，方法的泛型参数指定了启动模块。 通过WebApplicationBuilder编译得到WebApplication后，调用Abp定义的扩展方法InitializeApplication，他将初始化Abp应用，根据模块的依赖关系初始化启动模块及其依赖的模块。 var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"模块 Abp设计为模块化的应用程序框架，每一个模块都应定义一个继承自AbpModule的类，并以Module后缀作为类名。不同的模块间会存在依赖关系，模块的依赖关系通过DependsOn特性来定义。每个C#项目只应定义一个模块。 在ConfigureServices方法中，可以将依赖项注册到依赖注入系统中。在Abp中，通过约定大于配置的方式进行依赖项注册，项目代码通常无需在这里手动注册。ConfigureServices方法将在实例化Abp应用的时候调用以进行依赖项注册。 初始化Abp应用时，将会按照依赖顺序初始化所有的模块。初始化启动项模块时将会调用OnApplicationInitialization方法，通常在这个方法中会构建中间件管道。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); app.UseConfiguredEndpoints(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Swagger 添加Nuget包引用Volo.Abp.Swashbuckle及其模块依赖。Abp对Swagger进行了一些功能上的完善，比如防止跨站点请求伪造攻击，因此在项目中需要使用Volo.Abp.Swashbuckle。Volo.Abp.Swashbuckle自定义了swagger所需的js文件，他位于Volo.Abp.Swashbuckle模块的wwwroot文件夹中，因此需要通过UseStaticFiles扩展方法添加静态文件中间件支持。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpSwashbuckleModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureSwaggerServices(context); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseAbpSwaggerUI(c =\u003e { c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"CatchException API\"); }); } app.UseConfiguredEndpoints(); } private static void ConfigureSwaggerServices(ServiceConfigurationContext context) { context.Services.AddAbpSwaggerGen(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:3","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"日志 添加Nuget包引用Serilog.AspNetCore、Serilog.Sinks.Async到项目中。 在应用程序启动时，首先创建一个Serilog日志记录器，然后将构建并运行Web应用的操作通过try块包括起来捕获异常，在catch块中记录启动异常日志，在finally块中重置Serilog日志记录器。上述操作针对启动过程进行了日志记录，若要使应用通过Serilog记录日志，还需要UseSerilog扩展方法注册Serilog日志服务。更改Program.cs。 try { Log.Logger = new LoggerConfiguration() #if DEBUG .MinimumLevel.Debug() #else .MinimumLevel.Information() #endif .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Async(c =\u003e c.File(\"Logs/logs-.txt\", rollingInterval: RollingInterval.Day)) #if DEBUG .WriteTo.Async(c =\u003e c.Console()) #endif .CreateLogger(); var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac() .UseSerilog(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly!\"); return 1; } finally { Log.CloseAndFlush(); } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:4","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"启动 启动应用此时应导航到Swagger页面并可调用WeatherForecast接口获取数据。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:5","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章展示了如何从ASP.NET Core Web Api模板开始，手动集成Abp框架并将项目模块化，以当前项目作为启动模块创建并运行Abp应用。这里简单介绍了Abp应用及Abp模块，后续文章将逐步介绍Abp中的其他概念及用法。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":[".NET"],"content":"如何在生命周期为Singleton的服务中，解析生命周期为Scoped或Transient的依赖项。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"在依赖注入系统中，依赖项的生命周期通常分为瞬时的（Transient）、作用域的（Scoped）、单例的（Singleton）三种。单例生命周期的服务通常会在首次调用时创建，后续每此调用都会使用同一实例。 单例服务若依赖其他生命周期为瞬时或作用域的服务时，无法通过构造函数注入依赖项。构造函数只会在创建实例时调用一次，若将依赖项通过构造函数注入并赋值给单例服务的本地成员，依赖项的生命周期结束后销毁后，指向依赖项的本地成员将会指向空引用，且永远不会再次被赋值（只在调用构造函数时赋值）。运行时会抛出异常Cannot consume scoped service 'XXX' from singleton 'XXX'.。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:0:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"解决方案 在依赖瞬时生命周期或作用域生命周期依赖项的单例服务中，不直接通过构造函数注入依赖项，而是注入IServiceScopeFactory，在需要用到依赖项的方法中，通过IServiceScopeFactory创建作用域并解析依赖项。 public class MySingletonService : IMySingletonService { private readonly IServiceScopeFactory _scopeFactory; public MySingletonService(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Scoped() { using var scope = _scopeFactory.CreateScope(); var ctx = scope.ServiceProvider.GetRequiredService\u003cMyDbContext\u003e(); } } ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:1:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":["ASP.NET Core"],"content":"配置在开发环境中使用HTTP而不是HTTPS，配置不同的端口号。","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["ASP.NET Core"],"content":"在开发ASP.NET Core的项目时，默认地是使用HTTPS安全协议的。有时候可能不希望在本地的开发环境中使用HTTPS，更改这一默认行为非常简单。 移除UseHttpsRedirection中间件 app.UseHttpsRedirection中间件会将所有HTTP请求重定向到HTTPS，因此首先我们需要将其删除。中间件配置一般在Program.cs或Startup.cs中。 配置launchSettings.json launchSettings.json在项目的Properties目录下，它只对本地的开发环境生效，部署时会被忽略。通过dotnet new或者Visual Studio生成的ASP.NET Core项目会创建launchSettings.json文件。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 44324 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"https://localhost:7072;http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 将applicationUrl从https更改为http即可更改默认的应用启动Url，若使用IIS启动，还需将iisSettings中的sslPort设为0。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 0 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 此外，在launchSettings.json中，也可以通过applicationUrl更改应用启动的端口号。 ","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/:0:0","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["abp"],"content":"在Abp框架中，如何将ExtraProperties额外属性作为查询条件进行数据检索。","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"Abp框架提供了实体扩展系统，允许在不对类的定义进行更改的情况下，向对象中添加额外的属性。默认地，额外属性是以json对象的形式存储在数据库表的ExtraProperties字段中，因此无法直接将额外属性作为查询条件。对于额外属性，Abp支持将其通过Entity Framework Core映射为数据库表的单独字段，因此我们可以利用数据库映射来实现根据额外属性进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:0:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"数据库映射 将额外属性映射为数据库表字段非常容易。 通过Abp启动模板创建的解决方案中，预先生成了处理数据库映射的*EfCoreEntityExtensionMappings类，它位于*.EntityFrameworkCore项目中。在项目启动时，将会执行其中的Configure方法，通过OneTimeRunner执行一次操作。 在OneTimeRunner.Run()方法的Action参数中，通过ObjectExtensionManager来处理额外属性到数据库表字段的映射。 ObjectExtensionManager.Instance .AddOrUpdateProperty\u003cIdentityUser, string\u003e( \"Gender\", options =\u003e { options.MapEfCore((b, p) =\u003e { b.HasIndex(\"Gender\"); p.IsRequired().HasDefaultValue(string.Empty); p.HasMaxLength(8); }); } ); 在AddOrUpdateProperty方法中还可以设置表字段长度等，也可设置表的属性如索引。 添加数据迁移脚本并运行*.DbMigrator更新数据库接口，可以看到表中多出一个名为Gender的字段。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:1:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"查询 在*.EntityFramework.Core项目中创建仓储，并创建查询方法。 public async Task\u003cIdentityUser\u003e GetUserByGenderAsync(string gender) { return await (await GetDbSetAsync()) .FromSqlRaw($\"select * from AbpUsers where Gender == '{gender}'\") .FirstOrDefaultAsync(); } 调用方法GetUserByGenderAsync并传入gender参数即可根据Gender进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:2:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"总结 在这篇文章中，描述了如何对额外属性进行数据库映射，以及将额外属性作为查询条件检索数据。值得注意的是，将额外属性作为查询条件并不是最佳实践，如果可能的话应当尽量避免。此外，如需将拥有额外属性的Entity通过AutoMapper映射为Dto，不要忘记对Dto进行扩展并配置AutoMapperProfile。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:3:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["maui"],"content":"如何在Maui中使用依赖注入","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"依赖关系注入(DI)是 .NET 中的一等公民，如果熟悉 .NET 开发，对依赖注入则不会陌生。依赖关系注入是一种在类及其依赖关系之间实现控制反转(IoC)的技术，其中要反转的是获取依赖项的过程。通过依赖关系注入，分离了对象构建和对象使用的关注点，提高了代码的可读性和重用性。 .NET Multi-platform App UI 框架支持依赖关系注入软件设计模式。在 MVVM 模式中，依赖注入通常用于注册和解析视图模型，并注册和解析视图模型所依赖的服务。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:0:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"容器 容器负责构造并注入服务，管理服务的生命周期。拥有依赖项的类，只需关注对于依赖项的使用，无需关注依赖项的创建与管理——这个过程由容器进行处理。.NET 中提供了内置的服务容器IServiceProvider，可以使用IServiceProvider来解析依赖的服务。 一般地，在应用程序启动时，将服务注册到IServiceCollection中，然后调用BuildServiceProvider扩展方法，即可得到IServiceProvider容器。 在 Maui 中，生成IServiceProvider的过程是框架自动完成的，只需要在MauiProgram.cs中将服务注册到IServiceCollection即可。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:1:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注册服务 在注入服务前，必须先将服务注册到容器中。Maui 内置的容器ISeviceProvider位于MauiApp中。 应用程序启动时，调用MauiProgram.cs中的 CreateMauiApp设置并构造MauiApp。首先调用 CreateBuilder创建一个构造器，通过这个构造器完成创建MauiApp所需的全部设置，其中包括服务注册，最终通过Build方法构造 MauiApp 实例。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); }); return builder.Build(); } } 在.NET中注册服务，就是在应用程序启动时，将服务注册到 IServiceCollection 中。在MauiAppBuilder中，存在IServiceCollection类型的属性Services。因此，在 Maui 应用程序中注册服务，只需在构造MauiApp时将服务添加到MauiAppBuilder中的 Services中。 public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); ... builder.Services.AddSingleton\u003cMainPage\u003e(); return builder.Build(); } 在进行依赖关系注入时，需要从容器中解析服务。通过调用IServiceCollection的扩展方法 BuildServiceProvider可以构造获取 IServiceProvider容器实例。 调用MauiAppBuilder的Build方法获取 MauiApp实例时，将调用BuildServiceProvider，构造出IServiceProvider并赋值给MauiApp中的Services属性。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:2:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注入服务 注册服务后，可以通过容器来解析服务实例，也可将其作为依赖项进行注入。 依赖关系注入通常有构造函数注入、属性注入与方法注入三种方式。在 Maui 中，一般会使用构造方法注入依赖项，在平台代码中有时也会直接通过MauiApp实例来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } 将MainPage注册到容器中后，可以通过构造函数注入的方式将其作为依赖项注入。在特定平台的代码中，有时无法使用构造函数注入，这时可以直接通过容器解析依赖项。 public class MyActivity : MauiAppCompatActivity { private readonly IHelloService _helloService; public MyActivity() { _helloService = MauiApplication.Current.Services.GetRequiredService\u003cIHelloService\u003e(); } } ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:3:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"推荐内容 如何在Maui中使用Autofac 如何在 Maui 中全局处理异常 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:4:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["Abp"],"content":"轻量化Abp框架","date":"2021-07-23","objectID":"/posts/lightweightabp/","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们…”。事实上，Abp框架真的很重吗？ 框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分： 所依赖程序集的数量 所实现的功能的多少 上手难度及易用性 “轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。 这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:0:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"最小依赖 Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了展示层、应用层、领域层与基础设施层。 我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。 从架构设计上来讲，模块化是Abp的核心；而从技术角度来看，依赖注入则是Abp实现众多功能的一个主要手段。只要了解Abp的模块化和依赖注入，我们就能够基于Abp框架来进行项目开发。 接下来将创建一个原生的ASP.NET Core Web API项目，围绕模块化和依赖注入两个核心概念，来展示如何以最小依赖的方式使用Abp。 通过VS或者dotNet cli新建一个原生的ASP.NET Core Web API项目，命名为LightweightAbp； 安装Nuget包Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc； 将项目进行模块化：在项目根目录新建一个Abp模块代码文件LightweightAbpModule.cs，并复制以下代码： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { } } 将Startup中的代码调整到LightweightAbpModule中，代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddControllers(); context.Services.AddSwaggerGen(c =\u003e { c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"LightweightAbp\", Version = \"v1\" }); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseSwagger(); app.UseSwaggerUI(c =\u003e c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"LightweightAbp v1\")); } app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers(); }); } } 更改Startup中的代码以使用Abp的模块化系统： public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddApplication\u003cLightweightAbpModule\u003e(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory) { app.InitializeApplication(); } } 更改Program的CreateHostBuilder方法以使用Abp的依赖注入系统（基于Autofac）： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseStartup\u003cStartup\u003e(); }) .UseAutofac(); 将项目生成的WeatherForecastController基类ControllerBase更改为AbpController。 按F5运行。 至此项目的创建完成了。可以看到，仅仅依赖了Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:1:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"功能按需使用 得益于模块化设计，Abp将其所能提供的功能，划分并封装到了不同的模块中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（DependsOn）模块即可。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"数据访问 要想实现数据访问功能，首先我们需要定义Entity、DbContext并配置数据库支持。在Abp的层次架构中，Entity、Repository属于领域层，Service属于应用层，DbContext则属于EntityFramework Core模块，因此我们按需引入所需模块即可。 安装Nuget包Volo.Abp.Ddd.Application、Volo.Abp.Ddd.Domain和Volo.Abp.EntityFrameworkCore.Sqlite； 在LightweightAbpModule类中配置DependsOn特性，将AbpDddApplicationModule、AbpDddDomainModule和AbpEntityFrameworkCoreSqliteModule模块依赖到我们的项目模块中。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpDddApplicationModule), typeof(AbpDddDomainModule), typeof(AbpEntityFrameworkCoreSqliteModule))] public class LightweightAbpModule : AbpModule { ... } 然后创建实体Book及数据库上下文LightweightAbpDbContext: using System; using Volo.Abp.Domain.Entities; namespace LightweightAbp { public class Book : Entity\u003cGuid\u003e { public string Name { get; set; } } } [ConnectionStringName(\"Default\")] public class LightweightAbpDbContext : AbpDbContext\u003cLightweightAbpDbContext\u003e { public LightweightAbpDbContext(DbContextOptions\u003cLightweightAbpDbContext\u003e options) : base(options) { } public DbSet\u003cBook\u003e Books { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); builder.Entity\u003cBook\u003e(b =\u003e { b.ToTable(nameof(Books)); }); } } 在LightweightAbpModule的ConfigureServices方法中配置数据库访问： public override void ConfigureServices(ServiceConfigurationContext context) { ... context.Services.AddAbpDbContext\u003cLightweightAbpDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseSqlite(); }); } 在appsettings.json中配置数据库连接字符串 { ... \"ConnectionStrings\": { \"Default\": \"Data Source=LightweightAbp.db\" } } 安装Nuget包\"Microsoft.EntityFrameworkCore.Tools\",并在在项目根目录下打开命令行工具，依次执行以下命令进行数据迁移和数据库更新： dotnet ef migrations add InitialCreate dotnet ef database update 创建IBookAppService及BookAppService: public interface IBookAppService { Task CreateAsync(string name); } public class BookAppService : ApplicationService, IBookAppService { public IRepository\u003cBook, Guid\u003e Repository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cBook, Guid\u003e\u003e(); public async Task\u003cstring\u003e CreateAsync(string name) { var book = await Repository.InsertAsync(new Book() { Name = name }); return book.Name; } } 在文件夹Controllers中创建BookController: [ApiController] [Route(\"[controller]\")] public class BookController : AbpController { private readonly IBookAppService _service; public BookController(IBookAppService service) { _service = service; } [HttpGet] public Task\u003cstring\u003e CreateAsync(string name) { return _service.CreateAsync(name); } } F5以调试模式运行即可在Swagger页面上插入数据： 这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 ASP.NET Core Web API方式进行开发。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:1","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"缓存 接下来我们将继续实现缓存功能。 引用Nuget包Volo.Abp.Caching并向LightweightAbpModule添加AbpCachingModule模块依赖； 修改IBookAppService及BookAppService实现GetAllAsync方法： public interface IBookAppService { Task\u003cstring\u003e CreateAsync(string name); Task\u003cstring[]\u003e GetAllAsync(); } public class BookAppService : ApplicationService, IBookAppService { private readonly IRepository\u003cBook, Guid\u003e _repository; private readonly IDistributedCache\u003cstring[]\u003e _cache; public BookAppService( IRepository\u003cBook, Guid\u003e repository, IDistributedCache\u003cstring[]\u003e cache) { _repository = repository; _cache = cache; } public async Task\u003cstring\u003e CreateAsync(string name) { ... } public async Task\u003cstring[]\u003e GetAllAsync() { return await _cache.GetOrAddAsync( \"AllBooksName\", async () =\u003e await _repository.Select(b =\u003e b.Name).ToArrayAsync(), () =\u003e new DistributedCacheEntryOptions { AbsoluteExpiration = DateTimeOffset.Now.AddHours(1) } ); } } 修改BookAppService实现GetAllAsyncAPI接口： public class BookController : AbpController { ... [HttpGet(\"all\")] public Task\u003cstring[]\u003e GetAllAsync() { return _service.GetAllAsync(); } } F5以调试方式运行，即可调用实现了缓存功能的GetAllAsync接口。 这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。 众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于模块化的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:2","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"上手难度及易用性 学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。 对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。 如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是模块化及依赖注入的观点，当我们将入门的重点放在模块化和依赖注入上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。 至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现模块化的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的模块化给我们提供了轻易切换到微服务方案的能力；依赖注入系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:3:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"总结 在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。 项目示例代码将托管在Github中。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:4:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"致谢 感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:5:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"}]