[{"categories":["Abp极简教程"],"content":"在CatchE项目中引入领域服务，来处理业务逻辑。","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"在上一篇教程中，分析了CatchE项目的业务逻辑，得到了核心域，并对Issue、Answerer聚合建模。这篇文章中将创建领域服务，来完成提问Issue的功能。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"领域服务 DDD 领域服务处理业务规则。实现业务逻辑时，首先应考虑实体。如果实体无法独立实现业务，或者某个操作过程不属于实体的职责时，便应该将其放在领域服务中。 在CatchE中，提出一个Issue时，应选择一个Answerer回答问题。若不存在Answerer与选中的用户匹配，则根据选中用户进行创建。 通过构造函数创建Issue时，无法得知回答者是否存在，也无法创建Answerer。对Answerer的处理不是Issue的职责,因此创建领域服务来实现创建Issue的业务逻辑。 创建类IssueManager，继承DomainService。Abp框架遵循了约定大于配置的概念，继承了DomainService的类，Abp会将其视为领域服务并注册到依赖注入容器中。 领域服务通常不会有多个不同的实现，因此无需为领域服务创建单独的接口。 public class IssueManager : DomainService { } 需要通过仓储来判断Answerer是否存在，通过DomainService的LazyServiceProvider以懒加载的方式注入IRepository\u003cAnswerer, Guid\u003e。 注意 仓储及仓储的实现，将在后面的文章中介绍。 protected IRepository\u003cAnswerer, Guid\u003e AnswererRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cAnswerer, Guid\u003e\u003e(); 新建Answerer时，需要确保IdentityUserId这一用户是存在的，因此还需注入IRepository\u003cIdentityUser, Guid\u003e仓储。IdentityUser在Volo.Abp.Identity.Domain中定义，将Nuget包引用添加到项目中，并更改模块依赖。AbpIdentityDomainModule已依赖AbpDddDomainModule，CatchEDomainModule无需再次依赖，Volo.Abp.Ddd.Domain包引用也可从项目中移除。 [DependsOn( typeof(AbpIdentityDomainModule))] public class CatchEDomainModule : AbpModule { } 创建方法CreateAsync，方法中首先判断Answerer是否存在，若不存在则新建。完成Answerer的处理后，创建Issue并将其指派给Answerer。完整代码如下。 public class IssueManager : DomainService { protected IRepository\u003cAnswerer, Guid\u003e AnswererRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cAnswerer, Guid\u003e\u003e(); protected IRepository\u003cIdentityUser, Guid\u003e IdentityUserRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cIdentityUser, Guid\u003e\u003e(); public async Task\u003cIssue\u003e CreateAsync( Guid answererIdentityUserId, string title, string description) { var answerer = await AnswererRepository .SingleOrDefaultAsync(a =\u003e a.IdentityUserId == answererIdentityUserId); if (answerer is null) { var userExists = await IdentityUserRepository .AnyAsync(u =\u003e u.Id == answererIdentityUserId); if (!userExists) { throw new UserFriendlyException(\"用户不存在\"); } answerer = await AnswererRepository.InsertAsync( new Answerer( GuidGenerator.Create(), answererIdentityUserId)); } var issue = new Issue( GuidGenerator.Create(), title, description); issue.AssignTo(answerer); return issue; } } 唯一标识 实体的唯一标识应在实例化的时候由构造函数的调用方提供。通过GuidGenerator.Create()可生成顺序GUID。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章中介绍了领域服务的概念，并通过分析创建Issue业务逻辑，完成了对领域服务的建模。下一篇文章将会分析CatchE应用程序的用例，并实现应用服务。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"分析CatchE项目的问题空间，创建领域模型，区分聚合并建模，了解实体与聚合根，划分限界上下文（Bounded Context）并形成上下文映射图（Context Map），采用共享内核（Shared Kernel的方式处理不同上下文间的关系。","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"在上一篇文章中手动创建了CatchE项目并集成了Abp框架，接下来将从业务需求开始，了解领域的基本概念，识别聚合，并对领域建模，来展示如何在Abp中实现业务逻辑。这篇教程还会简要介绍限界上下文、上下文映射图、共享内核等概念。 ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"领域 领域即是一个组织所做的事情以及其中所包含的一切，描述了业务规则。领域是应用软件要解决的问题空间。 CatchE问答平台的需求大致可以描述为以下几点： 提问者创建一个问题 问题拥有标题、描述、是否解决等属性 提问者可以请求一个回答者来回答问题 问题被拒绝回答后创建者可以请求新的回答者来回答问题 问题解决后创建者可将其标记为已解决 每个问题都将拥有一个回答 上述需求是业务成功的关键因素，因此它是核心域。此外还需要其他功能如身份验证、权限控制的支持，这些功能模块是支撑子域或通用子域。开发核心域的解决方案是一种关键性业务投入。 关注需求的代码实现 如果你对子域、支撑子域、通用子域知之甚少，那么请不要考虑他们，只需要将关注点集中在上述需求和如何实现以上需求即可。 为了将领域的关注点从实现细节如数据库、Web Api等分离开来，创建一个类库项目名为CatchE.Domain。领域层将专注于业务逻辑。 Abp项目是模块化的，在CatchE.Domain项目中添加Nuget包Volo.Abp.Ddd.Domain引用并创建CatchEDomainModule类。 [DependsOn( typeof(AbpDddDomainModule))] public class CatchEDomainModule : AbpModule { } ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"聚合 在要解决的问题中，存在问题、答案、回答者，将他们命名为：Issue、Answer、Answerer。 对于Answer，他将是Issue的一部分，无法离开Issue单独存在，而且它们还拥有事务一致性，因此将Issue和Answer划分为一个聚合，并将Issue建模为聚合根。 Answerer和Issue聚合不存在强耦合关系，可以独立地维护Answerer的状态，因此以Answerer为聚合根建模为另一个聚合。 ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"Issue聚合 Issue聚合根 创建聚合根Issue，继承FullAuditedAggregateRoot\u003cGuid\u003e。关于不同聚合根基类的区别，详见Abp文档。 为聚合根Issue添加属性Title、Description、AnswererId和IsResolved。 显式将无参构造函数访问级别设为private(或protected)供ORM反序列化对象时使用，并可限制对象实例化的方式，阻止非法的实例化。 创建以唯一标识、title、和description作为参数的构造函数。基于及早生成唯一标识的原则，将唯一标识作为参数传入构造函数中，并调用base为唯一标识Id赋值。在Issue对象正确实例化后，Title和Description绝不能为null，因此在构造函数中为它们赋值，并将它们的set访问器访问级别设为private。在构造函数中，首先利用Abp提供的Check实现守卫，对参数进行非空检查，然后将其赋值给属性。 值得一提的是，Issue只能通过有参的构造函数来实例化，将创建Issue所需的所有信息都传递给构造函数，构造函数保证满足所有固定规则，使得创建操作是原子的，保证得到的对象是合法的。这也是构造函数这一机制的本意，对象的创建应通过构造函数来进行，构造函数保证对象的合法性。 慎用无参构造函数 很多代码中，首先调用无参构造函数，然后通过属性的set访问器更改状态，从而完成对象的创建，创建对象的职责从构造函数转移到了编码人员，这种行为在一个长期迭代的软件系统中是相当危险的。 public class Issue : FullAuditedAggregateRoot\u003cGuid\u003e { public string Title { get; private set; } public string Description { get; private set; } public Guid? AnswererId { get; private set; } public bool IsResolved { get; private set; } private Issue() { } public Issue( Guid id, string title, string description) : base(id) { Title = Check.NotNullOrWhiteSpace(title, nameof(title)); Description = Check.NotNullOrWhiteSpace(description, nameof(description)); } } 问题可以指派给一个回答者，因此在Issue中添加方法： public Issue AssignTo(Answerer answerer) { if (AnswererId.HasValue) { throw new BusinessException(message: \"不可重复指派\"); } AnswererId = answerer.Id; return this; } 上文描述问题的业务规则时，提到“问题被拒绝回答后创建者可以指派新的回答者”，这一描述隐含着另一条规则：“只有问题被拒绝回答后才可以指派新的回答者”。因此在AssignTo方法的卫语句中对AnswererId进行判断并处理。 问题可以被取消指派（回答者拒绝回答问题）： public Issue CancelAssign() { AnswererId = null; return this; } 问题最终将会被解决： public Issue Resolved() { IsResolved = true; return this; } Answer实体 回答者在答案被采纳前可以修改回答。创建实体Answer，并继承AuditedEntity\u003cGuid\u003e。 public class Answer : AuditedEntity\u003cGuid\u003e { public Guid IssueId { get; init; } public string Content { get; private set; } public virtual Issue Issue { get; set; } private Answer() { } public Answer( Guid id, Guid issueId, string content) : base(id) { IssueId = issueId; Content = Check.NotNullOrWhiteSpace(content, nameof(content)); } } 回答者可以更改答案。 public Answer Change(string content) { Content = Check.NotNullOrWhiteSpace(content, nameof(content)); return this; } 将Answer作为导航属性添加到Issue中。 public virtual Answer Answer { get; set; } ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"Answerer聚合 CatchE中的用户，在“问答”业务的语境下，可能是一个回答者。若是CatchE中存在订单系统，那么CatchE中的用户，可能又是一个购买者。反过来说，无论是“问答”中的回答者，还是“订单”中的购买者，他们都是CatchE中的用户。 DDD “问答”和“订单”将是不同的领域（Domain），不同领域的语境是不同的限界上下文（Bounded Context）。CatchE的用户在“问答”这一限界上下文中将是回答者，在“订单”这一上下文中将是购买者。将CatchE的用户与“问答”中的回答者、“订单”中的购买者进行映射，便形成了上下文映射图（Context Map）。“问答”上下文与“订单”上下文将采用共享内核（Shared Kernel）的方式共享CatchE的用户信息。 创建类Answerer，并将IdentityUser的主键作为属性以共享用户信息。随着业务的深入，将为Answerer扩展更多的功能，比如设置赞赏码等。 public class Answerer : FullAuditedAggregateRoot\u003cGuid\u003e { public Guid IdentityUserId { get; set; } public string Name { get; set; } public Answerer( Guid id, Guid identityUserId, string name) : base(id) { IdentityUserId = identityUserId; Name = name; } } ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"AggregateRoot和Entity的区别 在Abp中，聚合根和实体主要有以下区别： 聚合根继承了IHasExtraProperties接口，集成了Abp的对象扩展功能，而实体没有； 默认地，Abp将仅为聚合根创建默认实现的仓储，不会为实体创建。（可更改） ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"总结 在这篇文章中，分析了CatchE项目的业务需求，得到了核心域，识别出核心域的两个聚合并对他们进行建模。在下一篇文章将引入领域服务来实现提问Issue的功能。 ","date":"2021-12-27","objectID":"/posts/abp-tutorial-2-entity/:4:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-2 聚合、实体","uri":"/posts/abp-tutorial-2-entity/"},{"categories":["Abp极简教程"],"content":"从手动创建项目CatchE开始，添加Abp应用、模块来集成Abp框架。","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp是一个基于.NET的开源应用程序框架，它遵循最佳实践和约定，根据DDD模式进行设计和开发，并提供了强大的基础设施和完整的架构。 Abp提供了项目启动模板，它依据DDD模式进行分层，并预先配置了常用的模块。启动模板中反映着领域驱动设计、最佳实践等多种概念，其中任一项都值得单独讨论。对于初学者而言，启动模板中的大量知识如潮水般瞬间涌入脑海，造成知识过载，无法聚焦当前真正要学习的知识。 本系列教程，将结合一个问答网站CatchE示例项目，从简单的.NET Web Api应用程序开始，搭建起基于Abp的Web应用程序框架，并逐步深入细节，旨在以一种缓和的学习曲线帮助初学者快速入门。教程中的每一篇文章，都将会针对特定的几个知识点进行阐述，来帮助读者聚焦知识点。 关注代码 教程中会对必要的领域驱动设计概念进行简单的描述，如果在阅读本教程时对其感到困惑，那么暂时不要深入领域驱动设计的细节，请专注于代码及代码的设计思路。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"创建应用 通过VS创建一个名为CatchEWeb Api应用，选择ASP.NET Core Web Api项目模板，或通过CLI执行dotnet new webapi -n CatchE。运行后将访问至Swagger页面。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"集成Abp 首先需要添加Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc Nuget包引用至项目中以集成Abp框架。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp应用 Abp框架中定义了IAbpApplication应用，项目启动时应构建应用并运行。应用包含了启动模块及其依赖，构建应用时需要指定启动模块。将Program.cs更改如下： var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac(); builder.Services.AddApplication\u003cCatchEModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); AddApplication扩展方法向依赖注入系统中注册单例的Abp应用，方法的泛型参数指定了启动模块，稍后在示例项目中将创建名为CatchEModule的模块。 InitializeApplication扩展方法初始化Abp应用，它将会根据模块的依赖关系初始化启动模块及其依赖的模块。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"模块 创建C#类文件命名为CatchEModule更改代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class CatchEModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureSwaggerServices(context); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseConfiguredEndpoints(); } private static void ConfigureSwaggerServices(ServiceConfigurationContext context) { context.Services.AddSwaggerGen(); } } Abp设计为模块化的应用程序框架，每一个模块都应定义一个继承自AbpModule的类，并以Module后缀作为类名。不同的模块间会存在依赖关系，模块的依赖关系通过DependsOn特性来定义。每个C#项目只应定义一个模块。 在ConfigureServices方法中，可以将依赖项注册到依赖注入系统中。在Abp中，可以通过约定大于配置的方式进行依赖项注册，项目代码通常无需在这里手动注册。示例程序在ConfigureServices方法中注册了Swagger相关服务。ConfigureServices方法将在实例化Abp应用的时候调用。 初始化Abp应用时，将会按照依赖顺序初始化所有的模块。初始化启动项模块时将会调用他的OnApplicationInitialization方法，通常在这个方法中会构建中间件管道。示例程序配置了路由和终结点管道，并在开发环境中配置Swagger中间件。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"日志 添加Nuget包引用Serilog.AspNetCore、Serilog.Sinks.Async到项目中，并更改Program.cs。 try { var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac() .UseSerilog(); builder.Services.AddApplication\u003cCatchEModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly!\"); return 1; } finally { Log.CloseAndFlush(); } 在应用程序启动时，首先创建一个Serilog日志记录器，然后将构建并运行Web应用的操作通过try块包括起来捕获异常，在catch块中记录启动异常日志，在finally块中重置Serilog日志记录器。上述操作针对启动过程进行了日志记录，若要使应用通过Serilog记录日志，还需要UseSerilog扩展方法注册Serilog日志服务（第20行代码）。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:3","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"启动 启动应用此时应导航到Swagger页面并可调用WeatherForecast接口获取数据。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:4","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章展示了如何从ASP.NET Core Web Api模板开始，手动集成Abp框架并将项目模块化，以当前项目作为启动模块创建并运行Abp应用。这里简单介绍了Abp应用及Abp模块，后续文章将逐步介绍Abp中的其他概念及用法。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":[".NET"],"content":"如何在生命周期为Singleton的服务中，解析生命周期为Scoped或Transient的依赖项。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"在依赖注入系统中，依赖项的生命周期通常分为瞬时的（Transient）、作用域的（Scoped）、单例的（Singleton）三种。单例生命周期的服务通常会在首次调用时创建，后续每此调用都会使用同一实例。 单例服务若依赖其他生命周期为瞬时或作用域的服务时，无法通过构造函数注入依赖项。构造函数只会在创建实例时调用一次，若将依赖项通过构造函数注入并赋值给单例服务的本地成员，依赖项的生命周期结束后销毁后，指向依赖项的本地成员将会指向空引用，且永远不会再次被赋值（只在调用构造函数时赋值）。运行时会抛出异常Cannot consume scoped service 'XXX' from singleton 'XXX'.。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:0:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"解决方案 在依赖瞬时生命周期或作用域生命周期依赖项的单例服务中，不直接通过构造函数注入依赖项，而是注入IServiceScopeFactory，在需要用到依赖项的方法中，通过IServiceScopeFactory创建作用域并解析依赖项。 public class MySingletonService : IMySingletonService { private readonly IServiceScopeFactory _scopeFactory; public MySingletonService(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Scoped() { using var scope = _scopeFactory.CreateScope(); var ctx = scope.ServiceProvider.GetRequiredService\u003cMyDbContext\u003e(); } } ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:1:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":["ASP.NET Core"],"content":"配置在开发环境中使用HTTP而不是HTTPS，配置不同的端口号。","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["ASP.NET Core"],"content":"在开发ASP.NET Core的项目时，默认地是使用HTTPS安全协议的。有时候可能不希望在本地的开发环境中使用HTTPS，更改这一默认行为非常简单。 移除UseHttpsRedirection中间件 app.UseHttpsRedirection中间件会将所有HTTP请求重定向到HTTPS，因此首先我们需要将其删除。中间件配置一般在Program.cs或Startup.cs中。 配置launchSettings.json launchSettings.json在项目的Properties目录下，它只对本地的开发环境生效，部署时会被忽略。通过dotnet new或者Visual Studio生成的ASP.NET Core项目会创建launchSettings.json文件。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 44324 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"https://localhost:7072;http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 将applicationUrl从https更改为http即可更改默认的应用启动Url，若使用IIS启动，还需将iisSettings中的sslPort设为0。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 0 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 此外，在launchSettings.json中，也可以通过applicationUrl更改应用启动的端口号。 ","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/:0:0","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["abp"],"content":"在Abp框架中，如何将ExtraProperties额外属性作为查询条件进行数据检索。","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"Abp框架提供了实体扩展系统，允许在不对类的定义进行更改的情况下，向对象中添加额外的属性。默认地，额外属性是以json对象的形式存储在数据库表的ExtraProperties字段中，因此无法直接将额外属性作为查询条件。对于额外属性，Abp支持将其通过Entity Framework Core映射为数据库表的单独字段，因此我们可以利用数据库映射来实现根据额外属性进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:0:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"数据库映射 将额外属性映射为数据库表字段非常容易。 通过Abp启动模板创建的解决方案中，预先生成了处理数据库映射的*EfCoreEntityExtensionMappings类，它位于*.EntityFrameworkCore项目中。在项目启动时，将会执行其中的Configure方法，通过OneTimeRunner执行一次操作。 在OneTimeRunner.Run()方法的Action参数中，通过ObjectExtensionManager来处理额外属性到数据库表字段的映射。 ObjectExtensionManager.Instance .AddOrUpdateProperty\u003cIdentityUser, string\u003e( \"Gender\", options =\u003e { options.MapEfCore((b, p) =\u003e { b.HasIndex(\"Gender\"); p.IsRequired().HasDefaultValue(string.Empty); p.HasMaxLength(8); }); } ); 在AddOrUpdateProperty方法中还可以设置表字段长度等，也可设置表的属性如索引。 添加数据迁移脚本并运行*.DbMigrator更新数据库接口，可以看到表中多出一个名为Gender的字段。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:1:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"查询 在*.EntityFramework.Core项目中创建仓储，并创建查询方法。 public async Task\u003cIdentityUser\u003e GetUserByGenderAsync(string gender) { return await (await GetDbSetAsync()) .FromSqlRaw($\"select * from AbpUsers where Gender == '{gender}'\") .FirstOrDefaultAsync(); } 调用方法GetUserByGenderAsync并传入gender参数即可根据Gender进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:2:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"总结 在这篇文章中，描述了如何对额外属性进行数据库映射，以及将额外属性作为查询条件检索数据。值得注意的是，将额外属性作为查询条件并不是最佳实践，如果可能的话应当尽量避免。此外，如需将拥有额外属性的Entity通过AutoMapper映射为Dto，不要忘记对Dto进行扩展并配置AutoMapperProfile。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:3:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["maui"],"content":"如何在Maui中使用依赖注入","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"依赖关系注入(DI)是 .NET 中的一等公民，如果熟悉 .NET 开发，对依赖注入则不会陌生。依赖关系注入是一种在类及其依赖关系之间实现控制反转(IoC)的技术，其中要反转的是获取依赖项的过程。通过依赖关系注入，分离了对象构建和对象使用的关注点，提高了代码的可读性和重用性。 .NET Multi-platform App UI 框架支持依赖关系注入软件设计模式。在 MVVM 模式中，依赖注入通常用于注册和解析视图模型，并注册和解析视图模型所依赖的服务。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:0:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"容器 容器负责构造并注入服务，管理服务的生命周期。拥有依赖项的类，只需关注对于依赖项的使用，无需关注依赖项的创建与管理——这个过程由容器进行处理。.NET 中提供了内置的服务容器IServiceProvider，可以使用IServiceProvider来解析依赖的服务。 一般地，在应用程序启动时，将服务注册到IServiceCollection中，然后调用BuildServiceProvider扩展方法，即可得到IServiceProvider容器。 在 Maui 中，生成IServiceProvider的过程是框架自动完成的，只需要在MauiProgram.cs中将服务注册到IServiceCollection即可。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:1:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注册服务 在注入服务前，必须先将服务注册到容器中。Maui 内置的容器ISeviceProvider位于MauiApp中。 应用程序启动时，调用MauiProgram.cs中的 CreateMauiApp设置并构造MauiApp。首先调用 CreateBuilder创建一个构造器，通过这个构造器完成创建MauiApp所需的全部设置，其中包括服务注册，最终通过Build方法构造 MauiApp 实例。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); }); return builder.Build(); } } 在.NET中注册服务，就是在应用程序启动时，将服务注册到 IServiceCollection 中。在MauiAppBuilder中，存在IServiceCollection类型的属性Services。因此，在 Maui 应用程序中注册服务，只需在构造MauiApp时将服务添加到MauiAppBuilder中的 Services中。 public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); ... builder.Services.AddSingleton\u003cMainPage\u003e(); return builder.Build(); } 在进行依赖关系注入时，需要从容器中解析服务。通过调用IServiceCollection的扩展方法 BuildServiceProvider可以构造获取 IServiceProvider容器实例。 调用MauiAppBuilder的Build方法获取 MauiApp实例时，将调用BuildServiceProvider，构造出IServiceProvider并赋值给MauiApp中的Services属性。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:2:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注入服务 注册服务后，可以通过容器来解析服务实例，也可将其作为依赖项进行注入。 依赖关系注入通常有构造函数注入、属性注入与方法注入三种方式。在 Maui 中，一般会使用构造方法注入依赖项，在平台代码中有时也会直接通过MauiApp实例来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } 将MainPage注册到容器中后，可以通过构造函数注入的方式将其作为依赖项注入。在特定平台的代码中，有时无法使用构造函数注入，这时可以直接通过容器解析依赖项。 public class MyActivity : MauiAppCompatActivity { private readonly IHelloService _helloService; public MyActivity() { _helloService = MauiApplication.Current.Services.GetRequiredService\u003cIHelloService\u003e(); } } ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:3:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["Abp"],"content":"轻量化Abp框架","date":"2021-07-23","objectID":"/posts/lightweightabp/","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们…”。事实上，Abp框架真的很重吗？ 框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分： 所依赖程序集的数量 所实现的功能的多少 上手难度及易用性 “轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。 这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:0:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"最小依赖 Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了展示层、应用层、领域层与基础设施层。 我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。 从架构设计上来讲，模块化是Abp的核心；而从技术角度来看，依赖注入则是Abp实现众多功能的一个主要手段。只要了解Abp的模块化和依赖注入，我们就能够基于Abp框架来进行项目开发。 接下来将创建一个原生的ASP.NET Core Web API项目，围绕模块化和依赖注入两个核心概念，来展示如何以最小依赖的方式使用Abp。 通过VS或者dotNet cli新建一个原生的ASP.NET Core Web API项目，命名为LightweightAbp； 安装Nuget包Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc； 将项目进行模块化：在项目根目录新建一个Abp模块代码文件LightweightAbpModule.cs，并复制以下代码： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { } } 将Startup中的代码调整到LightweightAbpModule中，代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddControllers(); context.Services.AddSwaggerGen(c =\u003e { c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"LightweightAbp\", Version = \"v1\" }); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseSwagger(); app.UseSwaggerUI(c =\u003e c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"LightweightAbp v1\")); } app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers(); }); } } 更改Startup中的代码以使用Abp的模块化系统： public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddApplication\u003cLightweightAbpModule\u003e(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory) { app.InitializeApplication(); } } 更改Program的CreateHostBuilder方法以使用Abp的依赖注入系统（基于Autofac）： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseStartup\u003cStartup\u003e(); }) .UseAutofac(); 将项目生成的WeatherForecastController基类ControllerBase更改为AbpController。 按F5运行。 至此项目的创建完成了。可以看到，仅仅依赖了Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:1:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"功能按需使用 得益于模块化设计，Abp将其所能提供的功能，划分并封装到了不同的模块中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（DependsOn）模块即可。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"数据访问 要想实现数据访问功能，首先我们需要定义Entity、DbContext并配置数据库支持。在Abp的层次架构中，Entity、Repository属于领域层，Service属于应用层，DbContext则属于EntityFramework Core模块，因此我们按需引入所需模块即可。 安装Nuget包Volo.Abp.Ddd.Application、Volo.Abp.Ddd.Domain和Volo.Abp.EntityFrameworkCore.Sqlite； 在LightweightAbpModule类中配置DependsOn特性，将AbpDddApplicationModule、AbpDddDomainModule和AbpEntityFrameworkCoreSqliteModule模块依赖到我们的项目模块中。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpDddApplicationModule), typeof(AbpDddDomainModule), typeof(AbpEntityFrameworkCoreSqliteModule))] public class LightweightAbpModule : AbpModule { ... } 然后创建实体Book及数据库上下文LightweightAbpDbContext: using System; using Volo.Abp.Domain.Entities; namespace LightweightAbp { public class Book : Entity\u003cGuid\u003e { public string Name { get; set; } } } [ConnectionStringName(\"Default\")] public class LightweightAbpDbContext : AbpDbContext\u003cLightweightAbpDbContext\u003e { public LightweightAbpDbContext(DbContextOptions\u003cLightweightAbpDbContext\u003e options) : base(options) { } public DbSet\u003cBook\u003e Books { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); builder.Entity\u003cBook\u003e(b =\u003e { b.ToTable(nameof(Books)); }); } } 在LightweightAbpModule的ConfigureServices方法中配置数据库访问： public override void ConfigureServices(ServiceConfigurationContext context) { ... context.Services.AddAbpDbContext\u003cLightweightAbpDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseSqlite(); }); } 在appsettings.json中配置数据库连接字符串 { ... \"ConnectionStrings\": { \"Default\": \"Data Source=LightweightAbp.db\" } } 安装Nuget包\"Microsoft.EntityFrameworkCore.Tools\",并在在项目根目录下打开命令行工具，依次执行以下命令进行数据迁移和数据库更新： dotnet ef migrations add InitialCreate dotnet ef database update 创建IBookAppService及BookAppService: public interface IBookAppService { Task CreateAsync(string name); } public class BookAppService : ApplicationService, IBookAppService { public IRepository\u003cBook, Guid\u003e Repository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cBook, Guid\u003e\u003e(); public async Task\u003cstring\u003e CreateAsync(string name) { var book = await Repository.InsertAsync(new Book() { Name = name }); return book.Name; } } 在文件夹Controllers中创建BookController: [ApiController] [Route(\"[controller]\")] public class BookController : AbpController { private readonly IBookAppService _service; public BookController(IBookAppService service) { _service = service; } [HttpGet] public Task\u003cstring\u003e CreateAsync(string name) { return _service.CreateAsync(name); } } F5以调试模式运行即可在Swagger页面上插入数据： 这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 ASP.NET Core Web API方式进行开发。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:1","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"缓存 接下来我们将继续实现缓存功能。 引用Nuget包Volo.Abp.Caching并向LightweightAbpModule添加AbpCachingModule模块依赖； 修改IBookAppService及BookAppService实现GetAllAsync方法： public interface IBookAppService { Task\u003cstring\u003e CreateAsync(string name); Task\u003cstring[]\u003e GetAllAsync(); } public class BookAppService : ApplicationService, IBookAppService { private readonly IRepository\u003cBook, Guid\u003e _repository; private readonly IDistributedCache\u003cstring[]\u003e _cache; public BookAppService( IRepository\u003cBook, Guid\u003e repository, IDistributedCache\u003cstring[]\u003e cache) { _repository = repository; _cache = cache; } public async Task\u003cstring\u003e CreateAsync(string name) { ... } public async Task\u003cstring[]\u003e GetAllAsync() { return await _cache.GetOrAddAsync( \"AllBooksName\", async () =\u003e await _repository.Select(b =\u003e b.Name).ToArrayAsync(), () =\u003e new DistributedCacheEntryOptions { AbsoluteExpiration = DateTimeOffset.Now.AddHours(1) } ); } } 修改BookAppService实现GetAllAsyncAPI接口： public class BookController : AbpController { ... [HttpGet(\"all\")] public Task\u003cstring[]\u003e GetAllAsync() { return _service.GetAllAsync(); } } F5以调试方式运行，即可调用实现了缓存功能的GetAllAsync接口。 这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。 众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于模块化的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:2","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"上手难度及易用性 学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。 对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。 如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是模块化及依赖注入的观点，当我们将入门的重点放在模块化和依赖注入上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。 至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现模块化的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的模块化给我们提供了轻易切换到微服务方案的能力；依赖注入系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:3:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"总结 在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。 项目示例代码将托管在Github中。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:4:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"致谢 感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:5:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"}]