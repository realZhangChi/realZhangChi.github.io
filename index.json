[{"categories":["maui"],"content":"在 Maui 中，结合 AOP 等技术，全局捕获 ViewModel 中产生的异常，并弹出 Toast 提示。","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"在“如何在Maui中使用Autofac”一文中介绍了，如何在 Maui 中使用 Autofac 依赖注入容器。使用 Autofac ，可以实现面向切面编程（AOP）等。在 Maui 中进行全局捕获并处理异常，可以利用 AOP 来实现。 这篇文章通过一个示例程序来展示了如何在 Maui 程序中集成 Autofac ，并基于 AOP 技术来实现全局异常处理功能。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:0:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"引用相关 Nuget 包 新建 Maui 项目，并添加 Autofac.Extensions.DependencyInjection、Autofac.Extras.DynamicProxy Nuget 包引用。 Autofac.Extensions.DependencyInjection 是将 Autofac 集成到 Maui 中需要使用的包，Autofac.Extras.DynamicProxy 使注册到 Autofac 容器中的服务能够被拦截，以实现 AOP。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:1:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"创建 ViewModel 在项目根目录下，创建 ViewModels 文件夹，并在其中创建 MainViewModel.cs。在 ViewModel 中定义名为 RaiseException 的方法，来模拟引发异常。 public class MainViewModel { public virtual void RaiseException() { throw new Exception(\"An Exception has been throw!\"); } } 虚方法 Autofac 对类进行拦截时，将会创建一个子类并继承被拦截的类，从而实现拦截。因此被拦截类中的方法必须定义为 virtual，以便子类对其重写。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:2:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"创建拦截器 定义拦截器，只需定义一个类，并使其继承 Castle.DynamicProxy.IInterceptor 接口即可。 在 ViewModels 文件夹中创建 Interceptors 文件夹，并在其中创建 ExceptionHandleInterceptor.cs。 public class ExceptionHandleInterceptor : IInterceptor { public void Intercept(IInvocation invocation) { try { invocation.Proceed(); } catch (Exception e) { // TODO: Handle exception } } } IInterceptor 接口中定义了 Intercept 方法。在 Intercept 方法中通过 try 代码块将被拦截方法的调用包括起来，来捕获被拦截服务的方法调用异常，在 catch 代码块中对异常进行处理。 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:3:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"集成 Toaster 展示异常消息 通过在界面弹出 Toast 的方式，可以实现异常消息的用户友好提示。在 Maui Android 中集成显示 Toast 提示框的详细内容，参见“在 Maui Android 中使用 Toaster”。 集成 Toaster 后，在 ExceptionHandleInterceptor 的 Intercept 方法的 catch 代码块调用 Toaster 并显示异常消息。 public class ExceptionHandleInterceptor : IInterceptor { public void Intercept(IInvocation invocation) { try { invocation.Proceed(); } catch (Exception e) { // 调用 Toaster 并显示异常消息 #if ANDROID Com.Hjq.Toast.Toaster.Show(e.Message); #endif } } } ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:3:1","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"注册服务及拦截器 编辑 MauiProgram.cs 文件，使 Maui 应用程序的依赖注入系统使用 Autofac 容器，并将服务及拦截器注册到容器中。关于更多在 Maui 项目中集成 Autofac 的内容，请参考“如何在Maui中使用Autofac”。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); // ...... builder.ConfigureContainer(new AutofacServiceProviderFactory((containerBuilder) =\u003e { containerBuilder.Populate(builder.Services); // 注册拦截器 containerBuilder.RegisterType\u003cExceptionHandleInterceptor\u003e(); containerBuilder.RegisterType\u003cMainPage\u003e(); // 注册ViewModel服务 containerBuilder.RegisterType\u003cMainViewModel\u003e() // 启用基于类的拦截器 .EnableClassInterceptors() // 配置拦截器 .InterceptedBy(typeof(ExceptionHandleInterceptor)); })); return builder.Build(); } } ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:4:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"效果测试 更改 MainPage.xaml.cs 代码，将 MainViewModel 注入进去，并在 OnCounterClicked 方法中调用 ViewModel 中的 RaiseException 来模拟引发异常。 public partial class MainPage : ContentPage { public MainPage(MainViewModel vm) { InitializeComponent(); BindingContext = vm; } private void OnCounterClicked(object sender, EventArgs e) { if (BindingContext is MainViewModel vm) { vm.RaiseException(); } } } 运行并点击按钮，可以看到异常被拦截处理并且弹出 Toast 显示异常消息。 异常消息提示 ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:5:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"参考内容 如何在Maui中使用Autofac 在 Maui Android 中使用 Toaster Type Interceptors — Autofac 6.0.0 documentation ","date":"2023-02-26","objectID":"/posts/handle-exception-in-maui/:6:0","tags":["maui","aop","autofac"],"title":"如何在 Maui 中全局处理异常","uri":"/posts/handle-exception-in-maui/"},{"categories":["maui"],"content":"如何在 Maui 项目中使用 Toaster","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"Toaster Android Sdk Toaster 是一个开源的 Android 吐司框架，原名 ToastUtils ，已更名为 Toaster 。 Toaster 项目在 github 上开源，地址：https://github.com/getActivity/Toaster. ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:1:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"Toaster 绑定库 在 Maui 项目中使用原生 SDK 非常简单，只需要创建绑定类库即可。在 MauiBinding 项目中已为 Toaster 创建好了绑定类库，并可在 Nuget 上下载。通过 Nuget 包管理器或 CLI 安装 Chi.MauiBinding.Android.Toaster 即可使用 Toaster。 ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:2:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"使用 Toaster ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"初始化 Toaster 根据 Toaster 文档，要使用 Toaster ，首先需要进行初始化配置。 在 Maui 项目的 Platforms/Android/MainApplication.cs 文件中，重写 OnCreate 方法，并调用 Toaster.Init(this); 来初始化 Toaster，完整代码如下： // 引用 Toaster Sdk 名称空间 using Com.Hjq.Toast; [Application] public class MainApplication : MauiApplication { public MainApplication(IntPtr handle, JniHandleOwnership ownership) : base(handle, ownership) { } protected override MauiApp CreateMauiApp() =\u003e MauiProgram.CreateMauiApp(); public override void OnCreate() { base.OnCreate(); // 初始化 Toaster Toaster.Init(this); } } ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:1","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"显示 Toast 创建一个空的 Maui 项目，并编辑 MainPage.xaml.cs 文件，在 OnCounterClicked 方法中编写调用 Toaster 的代码： private void OnCounterClicked(object sender, EventArgs e) { // 调用 Toaster 并显示字符串 #if ANDROID Com.Hjq.Toast.Toaster.Show(\"Toaster in Maui\"); #endif count++; if (count == 1) CounterBtn.Text = $\"Clicked {count} time\"; else CounterBtn.Text = $\"Clicked {count} times\"; SemanticScreenReader.Announce(CounterBtn.Text); } 效果如下： Toast in maui ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:3:2","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"更多用法 可查看 Toaster 文档来使用 Toaster 的更多功能。 ","date":"2023-02-23","objectID":"/posts/use-toaster-in-maui-android/:4:0","tags":["maui","binding library"],"title":"在 Maui Android 中使用 Toaster","uri":"/posts/use-toaster-in-maui-android/"},{"categories":["maui"],"content":"在Maui中使用Autofac容器来管理对象的生命周期","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"Autofac是一个开源的控制反转容器，通过将.NET程序的控制反转容器替换为Autofac，可以实现例如属性注入、面向切面编程等功能。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:0:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"引用Autofac 从NuGet引用 Autofac.Extensions.DependencyInjection包。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:1:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"使用Autofac容器 打开MauiProgram.cs文件，在所有代码最后、return builder.Build();之前，通过ConfigureContainer来使用AutofacServiceProviderFactory来构建使用Autofac容器： public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); fonts.AddFont(\"OpenSans-Semibold.ttf\", \"OpenSansSemibold\"); }); #if DEBUG builder.Logging.AddDebug(); #endif // 添加以下代码 builder.ConfigureContainer(new AutofacServiceProviderFactory((containerBuilder) =\u003e { // Once you've registered everything in the ServiceCollection, call // Populate to bring those registrations into Autofac. This is // just like a foreach over the list of things in the collection // to add them to Autofac. containerBuilder.Populate(builder.Services); // Make your Autofac registrations. Order is important! // If you make them BEFORE you call Populate, then the // registrations in the ServiceCollection will override Autofac // registrations; if you make them AFTER Populate, the Autofac // registrations will override. You can make registrations // before or after Populate, however you choose. containerBuilder.RegisterType\u003cMainPage\u003e(); containerBuilder.RegisterType\u003cMainViewModel\u003e(); })); return builder.Build(); } 在上述代码中，通过调用Populate方法，将Maui在ServiceCollection中的服务注册，配置到了Autofac容器中，然后通过RegisterType将项目中的服务注册到Autofac容器中。 关注代码顺序 上述步骤中的代码顺序至关重要，他将影响服务在容器中的注册，详情参见Autofac文档。 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:2:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"解析依赖项 通过上述步骤将依赖注入容器替换为Autofac，将不会影响在Maui中解析依赖项的方式。正如《如何在Maui中使用依赖注入》一文中所介绍的，可以通过构造函数来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:3:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["maui"],"content":"推荐内容 《如何在Maui中使用依赖注入》 ","date":"2023-02-21","objectID":"/posts/use-autofac-in-maui/:4:0","tags":["dependency injection","maui","autofac"],"title":"如何在Maui中使用Autofac","uri":"/posts/use-autofac-in-maui/"},{"categories":["Abp极简教程"],"content":"从手动创建项目CatchException开始，添加Abp应用、模块来集成Abp框架。","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp是一个基于.NET的开源应用程序框架，它遵循最佳实践和约定，根据DDD模式进行设计和开发，并提供了强大的基础设施和完整的架构。 Abp提供了项目启动模板，它依据DDD模式进行分层，并预先配置了常用的模块。启动模板中反映着领域驱动设计、最佳实践等多种概念，其中任一项都值得单独讨论。对于初学者而言，启动模板中的大量知识如潮水般瞬间涌入脑海，造成知识过载，无法聚焦当前真正要学习的知识。 本系列教程，将结合一个问答网站CatchException示例项目，从简单的.NET Web Api应用程序开始，搭建起基于Abp的Web应用程序框架，并逐步深入细节，旨在以一种缓和的学习曲线帮助初学者快速入门，理解Abp启动模板的分层项目。 关注代码 教程中会对必要的领域驱动设计概念进行简单的描述，如果在阅读本教程时对其感到困惑，那么暂时不要深入领域驱动设计的细节，请专注于代码及代码的设计思路。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"创建应用 通过VS创建一个名为CatchExceptionWeb Api应用，选择ASP.NET Core Web Api项目模板，或通过CLI执行dotnet new webapi -n CatchException。运行后将访问至Swagger页面。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"集成Abp 首先需要添加Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc Nuget包引用至项目中以集成Abp框架。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp应用 Abp框架中定义了IAbpApplication应用，这也是Abp项目的入口点，Abp应用包含了启动模块及其依赖。在项目启动时需要将Abp应用注册到依赖注入系统中去，并指定启动模块。Abp定义了AddApplication泛型扩展方法，它将Abp应用注册为单例，方法的泛型参数指定了启动模块。 通过WebApplicationBuilder编译得到WebApplication后，调用Abp定义的扩展方法InitializeApplication，他将初始化Abp应用，根据模块的依赖关系初始化启动模块及其依赖的模块。 var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"模块 Abp设计为模块化的应用程序框架，每一个模块都应定义一个继承自AbpModule的类，并以Module后缀作为类名。不同的模块间会存在依赖关系，模块的依赖关系通过DependsOn特性来定义。每个C#项目只应定义一个模块。 在ConfigureServices方法中，可以将依赖项注册到依赖注入系统中。在Abp中，通过约定大于配置的方式进行依赖项注册，项目代码通常无需在这里手动注册。ConfigureServices方法将在实例化Abp应用的时候调用以进行依赖项注册。 初始化Abp应用时，将会按照依赖顺序初始化所有的模块。初始化启动项模块时将会调用OnApplicationInitialization方法，通常在这个方法中会构建中间件管道。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); app.UseConfiguredEndpoints(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Swagger 添加Nuget包引用Volo.Abp.Swashbuckle及其模块依赖。Abp对Swagger进行了一些功能上的完善，比如防止跨站点请求伪造攻击，因此在项目中需要使用Volo.Abp.Swashbuckle。Volo.Abp.Swashbuckle自定义了swagger所需的js文件，他位于Volo.Abp.Swashbuckle模块的wwwroot文件夹中，因此需要通过UseStaticFiles扩展方法添加静态文件中间件支持。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpSwashbuckleModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureSwaggerServices(context); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseAbpSwaggerUI(c =\u003e { c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"CatchException API\"); }); } app.UseConfiguredEndpoints(); } private static void ConfigureSwaggerServices(ServiceConfigurationContext context) { context.Services.AddAbpSwaggerGen(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:3","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"日志 添加Nuget包引用Serilog.AspNetCore、Serilog.Sinks.Async到项目中。 在应用程序启动时，首先创建一个Serilog日志记录器，然后将构建并运行Web应用的操作通过try块包括起来捕获异常，在catch块中记录启动异常日志，在finally块中重置Serilog日志记录器。上述操作针对启动过程进行了日志记录，若要使应用通过Serilog记录日志，还需要UseSerilog扩展方法注册Serilog日志服务。更改Program.cs。 try { Log.Logger = new LoggerConfiguration() #if DEBUG .MinimumLevel.Debug() #else .MinimumLevel.Information() #endif .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Async(c =\u003e c.File(\"Logs/logs-.txt\", rollingInterval: RollingInterval.Day)) #if DEBUG .WriteTo.Async(c =\u003e c.Console()) #endif .CreateLogger(); var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac() .UseSerilog(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly!\"); return 1; } finally { Log.CloseAndFlush(); } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:4","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"启动 启动应用此时应导航到Swagger页面并可调用WeatherForecast接口获取数据。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:5","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章展示了如何从ASP.NET Core Web Api模板开始，手动集成Abp框架并将项目模块化，以当前项目作为启动模块创建并运行Abp应用。这里简单介绍了Abp应用及Abp模块，后续文章将逐步介绍Abp中的其他概念及用法。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":[".NET"],"content":"如何在生命周期为Singleton的服务中，解析生命周期为Scoped或Transient的依赖项。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"在依赖注入系统中，依赖项的生命周期通常分为瞬时的（Transient）、作用域的（Scoped）、单例的（Singleton）三种。单例生命周期的服务通常会在首次调用时创建，后续每此调用都会使用同一实例。 单例服务若依赖其他生命周期为瞬时或作用域的服务时，无法通过构造函数注入依赖项。构造函数只会在创建实例时调用一次，若将依赖项通过构造函数注入并赋值给单例服务的本地成员，依赖项的生命周期结束后销毁后，指向依赖项的本地成员将会指向空引用，且永远不会再次被赋值（只在调用构造函数时赋值）。运行时会抛出异常Cannot consume scoped service 'XXX' from singleton 'XXX'.。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:0:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"解决方案 在依赖瞬时生命周期或作用域生命周期依赖项的单例服务中，不直接通过构造函数注入依赖项，而是注入IServiceScopeFactory，在需要用到依赖项的方法中，通过IServiceScopeFactory创建作用域并解析依赖项。 public class MySingletonService : IMySingletonService { private readonly IServiceScopeFactory _scopeFactory; public MySingletonService(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Scoped() { using var scope = _scopeFactory.CreateScope(); var ctx = scope.ServiceProvider.GetRequiredService\u003cMyDbContext\u003e(); } } ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:1:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":["ASP.NET Core"],"content":"配置在开发环境中使用HTTP而不是HTTPS，配置不同的端口号。","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["ASP.NET Core"],"content":"在开发ASP.NET Core的项目时，默认地是使用HTTPS安全协议的。有时候可能不希望在本地的开发环境中使用HTTPS，更改这一默认行为非常简单。 移除UseHttpsRedirection中间件 app.UseHttpsRedirection中间件会将所有HTTP请求重定向到HTTPS，因此首先我们需要将其删除。中间件配置一般在Program.cs或Startup.cs中。 配置launchSettings.json launchSettings.json在项目的Properties目录下，它只对本地的开发环境生效，部署时会被忽略。通过dotnet new或者Visual Studio生成的ASP.NET Core项目会创建launchSettings.json文件。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 44324 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"https://localhost:7072;http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 将applicationUrl从https更改为http即可更改默认的应用启动Url，若使用IIS启动，还需将iisSettings中的sslPort设为0。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 0 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 此外，在launchSettings.json中，也可以通过applicationUrl更改应用启动的端口号。 ","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/:0:0","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["abp"],"content":"在Abp框架中，如何将ExtraProperties额外属性作为查询条件进行数据检索。","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"Abp框架提供了实体扩展系统，允许在不对类的定义进行更改的情况下，向对象中添加额外的属性。默认地，额外属性是以json对象的形式存储在数据库表的ExtraProperties字段中，因此无法直接将额外属性作为查询条件。对于额外属性，Abp支持将其通过Entity Framework Core映射为数据库表的单独字段，因此我们可以利用数据库映射来实现根据额外属性进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:0:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"数据库映射 将额外属性映射为数据库表字段非常容易。 通过Abp启动模板创建的解决方案中，预先生成了处理数据库映射的*EfCoreEntityExtensionMappings类，它位于*.EntityFrameworkCore项目中。在项目启动时，将会执行其中的Configure方法，通过OneTimeRunner执行一次操作。 在OneTimeRunner.Run()方法的Action参数中，通过ObjectExtensionManager来处理额外属性到数据库表字段的映射。 ObjectExtensionManager.Instance .AddOrUpdateProperty\u003cIdentityUser, string\u003e( \"Gender\", options =\u003e { options.MapEfCore((b, p) =\u003e { b.HasIndex(\"Gender\"); p.IsRequired().HasDefaultValue(string.Empty); p.HasMaxLength(8); }); } ); 在AddOrUpdateProperty方法中还可以设置表字段长度等，也可设置表的属性如索引。 添加数据迁移脚本并运行*.DbMigrator更新数据库接口，可以看到表中多出一个名为Gender的字段。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:1:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"查询 在*.EntityFramework.Core项目中创建仓储，并创建查询方法。 public async Task\u003cIdentityUser\u003e GetUserByGenderAsync(string gender) { return await (await GetDbSetAsync()) .FromSqlRaw($\"select * from AbpUsers where Gender == '{gender}'\") .FirstOrDefaultAsync(); } 调用方法GetUserByGenderAsync并传入gender参数即可根据Gender进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:2:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"总结 在这篇文章中，描述了如何对额外属性进行数据库映射，以及将额外属性作为查询条件检索数据。值得注意的是，将额外属性作为查询条件并不是最佳实践，如果可能的话应当尽量避免。此外，如需将拥有额外属性的Entity通过AutoMapper映射为Dto，不要忘记对Dto进行扩展并配置AutoMapperProfile。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:3:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["maui"],"content":"如何在Maui中使用依赖注入","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"依赖关系注入(DI)是 .NET 中的一等公民，如果熟悉 .NET 开发，对依赖注入则不会陌生。依赖关系注入是一种在类及其依赖关系之间实现控制反转(IoC)的技术，其中要反转的是获取依赖项的过程。通过依赖关系注入，分离了对象构建和对象使用的关注点，提高了代码的可读性和重用性。 .NET Multi-platform App UI 框架支持依赖关系注入软件设计模式。在 MVVM 模式中，依赖注入通常用于注册和解析视图模型，并注册和解析视图模型所依赖的服务。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:0:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"容器 容器负责构造并注入服务，管理服务的生命周期。拥有依赖项的类，只需关注对于依赖项的使用，无需关注依赖项的创建与管理——这个过程由容器进行处理。.NET 中提供了内置的服务容器IServiceProvider，可以使用IServiceProvider来解析依赖的服务。 一般地，在应用程序启动时，将服务注册到IServiceCollection中，然后调用BuildServiceProvider扩展方法，即可得到IServiceProvider容器。 在 Maui 中，生成IServiceProvider的过程是框架自动完成的，只需要在MauiProgram.cs中将服务注册到IServiceCollection即可。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:1:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注册服务 在注入服务前，必须先将服务注册到容器中。Maui 内置的容器ISeviceProvider位于MauiApp中。 应用程序启动时，调用MauiProgram.cs中的 CreateMauiApp设置并构造MauiApp。首先调用 CreateBuilder创建一个构造器，通过这个构造器完成创建MauiApp所需的全部设置，其中包括服务注册，最终通过Build方法构造 MauiApp 实例。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); }); return builder.Build(); } } 在.NET中注册服务，就是在应用程序启动时，将服务注册到 IServiceCollection 中。在MauiAppBuilder中，存在IServiceCollection类型的属性Services。因此，在 Maui 应用程序中注册服务，只需在构造MauiApp时将服务添加到MauiAppBuilder中的 Services中。 public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); ... builder.Services.AddSingleton\u003cMainPage\u003e(); return builder.Build(); } 在进行依赖关系注入时，需要从容器中解析服务。通过调用IServiceCollection的扩展方法 BuildServiceProvider可以构造获取 IServiceProvider容器实例。 调用MauiAppBuilder的Build方法获取 MauiApp实例时，将调用BuildServiceProvider，构造出IServiceProvider并赋值给MauiApp中的Services属性。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:2:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注入服务 注册服务后，可以通过容器来解析服务实例，也可将其作为依赖项进行注入。 依赖关系注入通常有构造函数注入、属性注入与方法注入三种方式。在 Maui 中，一般会使用构造方法注入依赖项，在平台代码中有时也会直接通过MauiApp实例来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } 将MainPage注册到容器中后，可以通过构造函数注入的方式将其作为依赖项注入。在特定平台的代码中，有时无法使用构造函数注入，这时可以直接通过容器解析依赖项。 public class MyActivity : MauiAppCompatActivity { private readonly IHelloService _helloService; public MyActivity() { _helloService = MauiApplication.Current.Services.GetRequiredService\u003cIHelloService\u003e(); } } ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:3:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"推荐内容 《如何在Maui中使用Autofac》 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:4:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["Abp"],"content":"轻量化Abp框架","date":"2021-07-23","objectID":"/posts/lightweightabp/","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们…”。事实上，Abp框架真的很重吗？ 框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分： 所依赖程序集的数量 所实现的功能的多少 上手难度及易用性 “轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。 这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:0:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"最小依赖 Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了展示层、应用层、领域层与基础设施层。 我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。 从架构设计上来讲，模块化是Abp的核心；而从技术角度来看，依赖注入则是Abp实现众多功能的一个主要手段。只要了解Abp的模块化和依赖注入，我们就能够基于Abp框架来进行项目开发。 接下来将创建一个原生的ASP.NET Core Web API项目，围绕模块化和依赖注入两个核心概念，来展示如何以最小依赖的方式使用Abp。 通过VS或者dotNet cli新建一个原生的ASP.NET Core Web API项目，命名为LightweightAbp； 安装Nuget包Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc； 将项目进行模块化：在项目根目录新建一个Abp模块代码文件LightweightAbpModule.cs，并复制以下代码： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { } } 将Startup中的代码调整到LightweightAbpModule中，代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddControllers(); context.Services.AddSwaggerGen(c =\u003e { c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"LightweightAbp\", Version = \"v1\" }); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseSwagger(); app.UseSwaggerUI(c =\u003e c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"LightweightAbp v1\")); } app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers(); }); } } 更改Startup中的代码以使用Abp的模块化系统： public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddApplication\u003cLightweightAbpModule\u003e(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory) { app.InitializeApplication(); } } 更改Program的CreateHostBuilder方法以使用Abp的依赖注入系统（基于Autofac）： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseStartup\u003cStartup\u003e(); }) .UseAutofac(); 将项目生成的WeatherForecastController基类ControllerBase更改为AbpController。 按F5运行。 至此项目的创建完成了。可以看到，仅仅依赖了Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:1:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"功能按需使用 得益于模块化设计，Abp将其所能提供的功能，划分并封装到了不同的模块中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（DependsOn）模块即可。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"数据访问 要想实现数据访问功能，首先我们需要定义Entity、DbContext并配置数据库支持。在Abp的层次架构中，Entity、Repository属于领域层，Service属于应用层，DbContext则属于EntityFramework Core模块，因此我们按需引入所需模块即可。 安装Nuget包Volo.Abp.Ddd.Application、Volo.Abp.Ddd.Domain和Volo.Abp.EntityFrameworkCore.Sqlite； 在LightweightAbpModule类中配置DependsOn特性，将AbpDddApplicationModule、AbpDddDomainModule和AbpEntityFrameworkCoreSqliteModule模块依赖到我们的项目模块中。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpDddApplicationModule), typeof(AbpDddDomainModule), typeof(AbpEntityFrameworkCoreSqliteModule))] public class LightweightAbpModule : AbpModule { ... } 然后创建实体Book及数据库上下文LightweightAbpDbContext: using System; using Volo.Abp.Domain.Entities; namespace LightweightAbp { public class Book : Entity\u003cGuid\u003e { public string Name { get; set; } } } [ConnectionStringName(\"Default\")] public class LightweightAbpDbContext : AbpDbContext\u003cLightweightAbpDbContext\u003e { public LightweightAbpDbContext(DbContextOptions\u003cLightweightAbpDbContext\u003e options) : base(options) { } public DbSet\u003cBook\u003e Books { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); builder.Entity\u003cBook\u003e(b =\u003e { b.ToTable(nameof(Books)); }); } } 在LightweightAbpModule的ConfigureServices方法中配置数据库访问： public override void ConfigureServices(ServiceConfigurationContext context) { ... context.Services.AddAbpDbContext\u003cLightweightAbpDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseSqlite(); }); } 在appsettings.json中配置数据库连接字符串 { ... \"ConnectionStrings\": { \"Default\": \"Data Source=LightweightAbp.db\" } } 安装Nuget包\"Microsoft.EntityFrameworkCore.Tools\",并在在项目根目录下打开命令行工具，依次执行以下命令进行数据迁移和数据库更新： dotnet ef migrations add InitialCreate dotnet ef database update 创建IBookAppService及BookAppService: public interface IBookAppService { Task CreateAsync(string name); } public class BookAppService : ApplicationService, IBookAppService { public IRepository\u003cBook, Guid\u003e Repository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cBook, Guid\u003e\u003e(); public async Task\u003cstring\u003e CreateAsync(string name) { var book = await Repository.InsertAsync(new Book() { Name = name }); return book.Name; } } 在文件夹Controllers中创建BookController: [ApiController] [Route(\"[controller]\")] public class BookController : AbpController { private readonly IBookAppService _service; public BookController(IBookAppService service) { _service = service; } [HttpGet] public Task\u003cstring\u003e CreateAsync(string name) { return _service.CreateAsync(name); } } F5以调试模式运行即可在Swagger页面上插入数据： 这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 ASP.NET Core Web API方式进行开发。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:1","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"缓存 接下来我们将继续实现缓存功能。 引用Nuget包Volo.Abp.Caching并向LightweightAbpModule添加AbpCachingModule模块依赖； 修改IBookAppService及BookAppService实现GetAllAsync方法： public interface IBookAppService { Task\u003cstring\u003e CreateAsync(string name); Task\u003cstring[]\u003e GetAllAsync(); } public class BookAppService : ApplicationService, IBookAppService { private readonly IRepository\u003cBook, Guid\u003e _repository; private readonly IDistributedCache\u003cstring[]\u003e _cache; public BookAppService( IRepository\u003cBook, Guid\u003e repository, IDistributedCache\u003cstring[]\u003e cache) { _repository = repository; _cache = cache; } public async Task\u003cstring\u003e CreateAsync(string name) { ... } public async Task\u003cstring[]\u003e GetAllAsync() { return await _cache.GetOrAddAsync( \"AllBooksName\", async () =\u003e await _repository.Select(b =\u003e b.Name).ToArrayAsync(), () =\u003e new DistributedCacheEntryOptions { AbsoluteExpiration = DateTimeOffset.Now.AddHours(1) } ); } } 修改BookAppService实现GetAllAsyncAPI接口： public class BookController : AbpController { ... [HttpGet(\"all\")] public Task\u003cstring[]\u003e GetAllAsync() { return _service.GetAllAsync(); } } F5以调试方式运行，即可调用实现了缓存功能的GetAllAsync接口。 这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。 众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于模块化的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:2","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"上手难度及易用性 学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。 对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。 如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是模块化及依赖注入的观点，当我们将入门的重点放在模块化和依赖注入上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。 至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现模块化的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的模块化给我们提供了轻易切换到微服务方案的能力；依赖注入系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:3:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"总结 在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。 项目示例代码将托管在Github中。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:4:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"致谢 感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:5:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"}]