[{"categories":["Abp极简教程"],"content":"向CatchException项目中集成Entity Framework Core框架，并实现仓储。了解领域驱动设计中的基础设施层。","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"在前几篇教程中，对领域进行了建模，开发了领域层，针对应用程序用例开发了应用层，还创建了负责数据适配的HttpApi接口。到目前为止，项目还无法运行起来，因为没有为仓储提供实现。这篇教程中将集成Entity Framework Core并实现仓储。 ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"集成Entity Framework Core 数据库作为基础设施，为实体仓储的持久化提供了支持。在CatchException项目中，将创建Entity Framework Core基础设施项目，负责集成数据库，并实现领域对象和数据库之间的数据适配。 整洁架构 在整洁架构中，数据库位于最外层的“框架与驱动程序”中，而Entity Framework Core基础设施项目则位于“接口与适配器层”，它负责将数据从便于项目开发的C#类的格式，转换为便于持久化到数据库的格式。本教程最后一篇将会对分层架构进行简单的阐述。 ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"Entity Framework Core模块 新建项目CatchException.EntityFrameworkCore，添加以下Nuget包引用集成Entity Framework Core。 Microsoft.EntityFrameworkCore Microsoft.EntityFrameworkCore.Relational Microsoft.EntityFrameworkCore.Tools 创建Abp模块CatchExceptionEntityFrameworkCoreModule，添加Abp的Nuget包Volo.Abp.EntityFrameworkCore.MySQL引用及AbpEntityFrameworkCoreMySQLModule模块依赖，添加项目引用CatchException.Domain及CatchExceptionDomainModule模块依赖，因为项目依赖Identity通用子域，因此还需添加Volo.Abp.Identity.EntityFrameworkCore包引用及AbpIdentityEntityFrameworkCoreModule模块依赖。 [DependsOn( typeof(AbpEntityFrameworkCoreMySQLModule), typeof(AbpIdentityEntityFrameworkCoreModule), typeof(CatchExceptionDomainModule))] public class CatchExceptionEntityFrameworkCoreModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseMySQL(); }); } } ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:1:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"创建DbContext 创建CatchExceptionDbContext并将聚合根的DbSet作为属性。在配置实体模型时，需要通过ConfigureByConvention扩展方法配置审计字段。ConfigureIdentity将配置Identity模块的实体。 public class CatchExceptionDbContext : AbpDbContext\u003cCatchExceptionDbContext\u003e { public DbSet\u003cIssue\u003e Issues { get; set; } public DbSet\u003cAnswerer\u003e Answerers { get; set; } public CatchExceptionDbContext(DbContextOptions\u003cCatchExceptionDbContext\u003e options) : base(options) { } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.ConfigureIdentity(); modelBuilder.Entity\u003cIssue\u003e(b =\u003e { b.ToTable(\"Issues\"); b.ConfigureByConvention(); b.Property(p =\u003e p.Title).HasMaxLength(128); b.Property(p =\u003e p.Description).HasMaxLength(2048); }); modelBuilder.Entity\u003cAnswerer\u003e(b =\u003e { b.ToTable(\"Answerers\"); b.ConfigureByConvention(); }); } } ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:1:2","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"数据迁移 创建设计时DbContext工厂，以供执行数据迁移命令时使用。 public class CatchExceptionDbContextFactory : IDesignTimeDbContextFactory\u003cCatchExceptionDbContext\u003e { public CatchExceptionDbContext CreateDbContext(string[] args) { var configuration = BuildConfiguration(); var builder = new DbContextOptionsBuilder\u003cCatchExceptionDbContext\u003e() .UseMySql(configuration.GetConnectionString(\"Default\"), MySqlServerVersion.LatestSupportedServerVersion); return new CatchExceptionDbContext(builder.Options); } private static IConfigurationRoot BuildConfiguration() { var builder = new ConfigurationBuilder() .SetBasePath(Path.Combine(Directory.GetCurrentDirectory(), \"../CatchException.HttpApi.Host/\")) .AddJsonFile(\"appsettings.json\", optional: false) .; return builder.Build(); } } 在CatchException.HttpApi.Host项目中配置连接字符串。 { \"ConnectionStrings\": { \"Default\": \"Server=127.0.0.1;Database=CatchException;User=root;Password=yourStrong(!)Password\" } } 在CatchException.EntityFrameworkCore项目目录下执行命令dotnet ef migrations add Initial生成迁移文件，并执行dotnet ef database update更新数据库。 ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:1:3","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"注册仓储 AddDefaultRepositories扩展方法将会为CatchExceptionDbContext中的聚合根DbSet注册默认的泛型仓储。默认地，只会为聚合根注册默认实现的反省仓储，若要为普通实体注册，将includeAllEntities参数改为true并将实体DbSet也添加到CatchExceptionDbContext中。 因为CatchExceptionEntityFrameworkCoreModule依赖了AbpIdentityEntityFrameworkCoreModule模块，在应用程序初始化时调用CatchExceptionEntityFrameworkCoreModule的ConfigureServices方法之前，会先调用AbpIdentityEntityFrameworkCoreModule模块的ConfigureServices方法来为其模块内的聚合根注册泛型仓储。 [DependsOn( typeof(AbpEntityFrameworkCoreMySQLModule), typeof(AbpIdentityEntityFrameworkCoreModule), typeof(CatchExceptionDomainModule))] public class CatchExceptionEntityFrameworkCoreModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddAbpDbContext\u003cCatchExceptionDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: false); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseMySQL(); }); } } ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"整合起来 基于依赖倒置的原则，CatchException.Domain不会依赖CatchException.EntityFrameworkCore具体实现，而是具体实现将依赖于Domain中的仓储接口。通过项目分层，将依赖项倒置了，那么还需要通过HttpApi.Host启动项目来将其整合起来。 依赖倒置 依赖于抽象，而不是具体实现。 将CatchException.EntityFrameworkCore项目引用添加至CatchException.HttpApi.Host项目中，并将CatchExceptionEntityFrameworkCoreModule模块添加到CatchExceptionHttpApiHostModule模块依赖项中。通过Host启动项目，将所有模块整合到一起，此时运行程序并调用接口，即可实现Issue的创建。 ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"总结 在这篇教程中，集成了Entity Framework Core框架，并通过EF Core实现了仓储，此外，还了解到了整洁架构中的“框架与驱动程序”、“接口与适配器”。下一篇教程中将会创建HttpApi.Client客户端代理项目。 ","date":"2022-01-06","objectID":"/posts/abp-turorial-6-entity-framework/:4:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-6 Entity Framework与仓储实现","uri":"/posts/abp-turorial-6-entity-framework/"},{"categories":["Abp极简教程"],"content":"了解Abp中的HttpApi，为CatchException项目创建HttpApi接口。","date":"2022-01-04","objectID":"/posts/abp-turorial-5-http-api/","tags":["Tutorials","Abp"],"title":"Abp极简教程-5 Api接口","uri":"/posts/abp-turorial-5-http-api/"},{"categories":["Abp极简教程"],"content":"HttpApi接口承担着数据转换器的职责，它将应用层的数据传输对象，转换为便于前端使用的json格式，也将前端调用Api时传入的json格式参数，转换为应用层所需要的数据传输对象。 ","date":"2022-01-04","objectID":"/posts/abp-turorial-5-http-api/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-5 Api接口","uri":"/posts/abp-turorial-5-http-api/"},{"categories":["Abp极简教程"],"content":"创建HttpApi 新建类库项目CatchException.HttpApi并引入Nuget包Volo.Abp.AspNetCore.Mvc，添加CatchException.Application项目引用。新建类CatchExceptionHttpApiModule并添加模块依赖。 [DependsOn( typeof(AbpAspNetCoreMvcModule), typeof(CatchExceptionApplicationModule))] public class CatchExceptionHttpApiModule : AbpModule { } 新建IssueController，继承AbpControllerBase，并通过IIssueAppService实现CreateAsync方法，以创建Issue。 [Route(\"api/issue\")] public class IssueController : AbpControllerBase { protected IIssueAppService AppService =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIIssueAppService\u003e(); [HttpPost] public Task\u003cIssueDto\u003e CreateAsync(CreateIssueDto input) { return AppService.CreateAsync(input); } } ","date":"2022-01-04","objectID":"/posts/abp-turorial-5-http-api/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-5 Api接口","uri":"/posts/abp-turorial-5-http-api/"},{"categories":["Abp极简教程"],"content":"集成 在CatchException.HttpApi.Host项目中引用CatchException.HttpApi项目，并添加CatchExceptionHttpApiModule模块依赖。运行项目导航至Swagger页面可看到刚添加的Api接口。 ","date":"2022-01-04","objectID":"/posts/abp-turorial-5-http-api/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-5 Api接口","uri":"/posts/abp-turorial-5-http-api/"},{"categories":["Abp极简教程"],"content":"总结 这篇教程中介绍了HttpApi的职责并为CatchException项目创建了Api接口，下一篇文章将集成Entity Framework Core并实现仓储。 ","date":"2022-01-04","objectID":"/posts/abp-turorial-5-http-api/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-5 Api接口","uri":"/posts/abp-turorial-5-http-api/"},{"categories":["Abp极简教程"],"content":"介绍应用层（Application Layer）、数据传输对象（DTO）、应用服务（Application Service），应用服务和领域服务(Domain Service)的区别，继承AutoMapper，在CatchException项目中实现应用服务。","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"上篇文章中，介绍了领域服务，并用领域服务实现了创建Issue的业务逻辑。下面介绍应用服务以及它和领域服务的区别，并在CatchException应用程序中实现创建Issue的功能。 ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"数据传输对象 数据传输对象（DTO）通常作为应用服务的参数，由展示层调用应用服务时传入；或作为应用服务的返回值类型，在应用服务方法执行完成后将结果返回给展示层。通过数据传输对象，将展示层与领域层完全隔离开来了。数据传输对象解决了阻抗失配的问题。 阻抗失配 展示层接收的数据格式与接口返回值的数据格式一致为阻抗匹配，接口接收的参数数据格式与展示层传入参数的数据格式一致为阻抗匹配。反之，属性多于或少于所需均为阻抗失配。 定义IssueDto和CreateIssueDto。 public class IssueDto : EntityDto\u003cGuid\u003e { public string Title { get; set; } public string Description { get; set; } public Guid? AnswererId { get; set; } public bool IsResolved { get; set; } } public class CreateIssueDto { [Required] public string Title { get; set; } [Required] public string Description { get; set; } public Guid AnswererId { get; set; } } ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"应用服务 应用服务实现了应用程序的用例，应用服务中的每一个方法对应着应用程序中的一个用例。“提交相关信息创建Issue并得到创建结果”是CatchException中的一个用例，他将对应着应用服务中的一个方法。应用服务中的方法，将负责用例的任务协调。 应用服务是领域模型的直接客户，调用协调领域模型来完成一个用例。创建Issue的应用服务方法会调用Issue、IssueManager、Repository等领域模型来完成Issue的创建。 应用服务负责控制事务以保证对模型修改的原子提交。在Abp中，自动通过UnitOfWork中间件控制事务。 应用服务负责安全相关的操作如权限控制。 注意 应用服务的职责都是和应用程序相关的，应用服务中的“应用”指的就是“应用程序”。 为了分离对应用程序职责的关注点，新建应用层类库项目CatchException.Application，添加Nuget包Volo.Abp.Ddd.Application引用，添加CatchException.Domain项目引用。为CatchException.Application创建Abp模块并添加模块依赖。 Contracts 在Abp中，单独为应用服务接口、数据传输对象创建一个Contracts层是有必要的，我们会在后续教程中创建。 [DependsOn( typeof(AbpDddApplicationModule), typeof(CatchExceptionDomainModule))] public class CatchExceptionApplicationModule : AbpModule { } 创建IIssueAppService应用服务接口，并定义CreateAsync方法，它将接收CreateIssueDto参数，返回IssueDto。 public interface IIssueAppService : IApplicationService { Task\u003cIssueDto\u003e CreateAsync(CreateIssueDto input); } 创建IssueAppService应用服务，继承IIssueAppService接口并实现。在CreateAsync方法中，首先协调领域模型进行创建Issue的这一应用程序用例：调用领域模型中的领域服务IssueManager创建一个Issue，然后调用领域模型中的仓储IssueRepository将实体Issue保存到仓储中。然后将创建的Issue映射为IssueDto并返回。 public class IssueAppService : ApplicationService, IIssueAppService { protected IssueManager IssueManager =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIssueManager\u003e(); protected IRepository\u003cIssue, Guid\u003e IssueRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cIssue, Guid\u003e\u003e(); public async Task\u003cIssueDto\u003e CreateAsync(CreateIssueDto input) { var issue = await IssueManager.CreateAsync( input.AnswererId, input.Title, input.Description); await IssueRepository.InsertAsync(issue); return ObjectMapper.Map\u003cIssue, IssueDto\u003e(issue); } } 跟随者模式 基于约定，Abp中的应用服务及其接口通常以AppService作为后缀，并分别继承ApplicationService和IApplicationService。遵循约定对于用好Abp是至关重要的，要做一个优秀的跟随着。 ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"应用服务和领域服务的区别 同为服务，他们的区别即为“应用”的“领域”的区别。 应用指的是“应用程序”，应用服务是和应用程序相关联的服务，如应用程序用例、应用程序权限与安全、应用程序的数据库事务。 领域指的是业务，领域服务则是和业务逻辑相关联的服务，它实现了和应用程序用例完全无关的业务逻辑。领域服务作为领域对象的一种，和实体、仓储、领域事件等共同组成了领域模型，而领域模型则是对业务的描述。 ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"使用AutoMapper 在应用服务的CreateAsync方法中，使用了ObjectMapper将实体映射为Dto。若要使用ObjectMapper对象映射功能，需要配置`AutoMapper。 创建CatchExceptionApplicationAutoMapperProfile并继承AutoMapper.Profile； 在构造函数中创建对象映射关系； 在CatchExceptionApplicationModule中将注册AutoMapper配置文件到项目中。 public class CatchExceptionApplicationAutoMapperProfile : Profile { public CatchExceptionApplicationAutoMapperProfile() { CreateMap\u003cIssue, IssueDto\u003e(); } } public override void ConfigureServices(ServiceConfigurationContext context) { Configure\u003cAbpAutoMapperOptions\u003e(options =\u003e { options.AddMaps\u003cCatchExceptionApplicationModule\u003e(); }); } AddMaps会对CatchExceptionApplicationModule程序集内所有继承了Profile的类进行注册。 ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章介绍了应用服务及应用层相关的概念，分析了应用服务和领域服务的区别。下一篇教程将会创建Web Api，并与CatchException启动项目集成。 ","date":"2021-12-29","objectID":"/posts/abp-turorial-4-application-service/:4:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-4 应用层及应用服务","uri":"/posts/abp-turorial-4-application-service/"},{"categories":["Abp极简教程"],"content":"在CatchException项目中引入领域服务，来处理业务逻辑。","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"在上一篇教程中，分析了CatchException项目的业务逻辑，得到了核心域，并对Issue、Answerer聚合建模。这篇文章中将创建领域服务，来完成提问Issue的功能。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"领域服务 DDD 领域服务处理业务规则。实现业务逻辑时，首先应考虑实体。如果实体无法独立实现业务，或者某个操作过程不属于实体的职责时，便应该将其放在领域服务中。 在CatchException中，提出一个Issue时，应选择一个Answerer回答问题。若不存在Answerer与选中的用户匹配，则根据选中用户进行创建。 通过构造函数创建Issue时，无法得知回答者是否存在，也无法创建Answerer。对Answerer的处理不是Issue的职责,因此创建领域服务来实现创建Issue的业务逻辑。 创建类IssueManager，继承DomainService。Abp框架遵循了约定大于配置的概念，继承了DomainService的类，Abp会将其视为领域服务并注册到依赖注入容器中。 领域服务通常不会有多个不同的实现，因此无需为领域服务创建单独的接口。 public class IssueManager : DomainService { } 需要通过仓储来判断Answerer是否存在，通过DomainService的LazyServiceProvider以懒加载的方式注入IRepository\u003cAnswerer, Guid\u003e。 protected IRepository\u003cAnswerer, Guid\u003e AnswererRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cAnswerer, Guid\u003e\u003e(); 新建Answerer时，需要确保IdentityUserId这一用户是存在的，因此还需注入IRepository\u003cIdentityUser, Guid\u003e仓储。IdentityUser在Volo.Abp.Identity.Domain中定义，将Nuget包引用添加到项目中，并更改模块依赖。AbpIdentityDomainModule已依赖AbpDddDomainModule，在CatchExceptionDomainModule中无需重复依赖，Volo.Abp.Ddd.Domain包引用也可从项目中移除。 [DependsOn( typeof(AbpIdentityDomainModule))] public class CatchExceptionDomainModule : AbpModule { } 创建方法CreateAsync，方法中首先判断Answerer是否存在，若不存在则新建。完成Answerer的处理后，创建Issue并将其指派给Answerer。完整代码如下。 public class IssueManager : DomainService { protected IRepository\u003cAnswerer, Guid\u003e AnswererRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cAnswerer, Guid\u003e\u003e(); protected IRepository\u003cIdentityUser, Guid\u003e IdentityUserRepository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cIdentityUser, Guid\u003e\u003e(); public async Task\u003cIssue\u003e CreateAsync( Guid answererIdentityUserId, string title, string description) { var answerer = await AnswererRepository .SingleOrDefaultAsync(a =\u003e a.IdentityUserId == answererIdentityUserId); if (answerer is null) { var userExists = await IdentityUserRepository .AnyAsync(u =\u003e u.Id == answererIdentityUserId); if (!userExists) { throw new UserFriendlyException(\"用户不存在\"); } answerer = await AnswererRepository.InsertAsync( new Answerer( GuidGenerator.Create(), answererIdentityUserId)); } var issue = new Issue( GuidGenerator.Create(), title, description); issue.AssignTo(answerer); return issue; } } 唯一标识 实体的唯一标识应在实例化的时候由构造函数的调用方提供。通过GuidGenerator.Create()可生成顺序GUID。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章中介绍了领域服务的概念，并通过分析创建Issue业务逻辑，完成了对领域服务的建模。下一篇文章将会分析CatchException应用程序的用例，并实现应用服务。 ","date":"2021-12-28","objectID":"/posts/abp-turorial-3-domain-service/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-3 领域服务","uri":"/posts/abp-turorial-3-domain-service/"},{"categories":["Abp极简教程"],"content":"从手动创建项目CatchException开始，添加Abp应用、模块来集成Abp框架。","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp是一个基于.NET的开源应用程序框架，它遵循最佳实践和约定，根据DDD模式进行设计和开发，并提供了强大的基础设施和完整的架构。 Abp提供了项目启动模板，它依据DDD模式进行分层，并预先配置了常用的模块。启动模板中反映着领域驱动设计、最佳实践等多种概念，其中任一项都值得单独讨论。对于初学者而言，启动模板中的大量知识如潮水般瞬间涌入脑海，造成知识过载，无法聚焦当前真正要学习的知识。 本系列教程，将结合一个问答网站CatchException示例项目，从简单的.NET Web Api应用程序开始，搭建起基于Abp的Web应用程序框架，并逐步深入细节，旨在以一种缓和的学习曲线帮助初学者快速入门。教程中的每一篇文章，都将会针对特定的几个知识点进行阐述，来帮助读者聚焦知识点。 关注代码 教程中会对必要的领域驱动设计概念进行简单的描述，如果在阅读本教程时对其感到困惑，那么暂时不要深入领域驱动设计的细节，请专注于代码及代码的设计思路。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:0:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"创建应用 通过VS创建一个名为CatchExceptionWeb Api应用，选择ASP.NET Core Web Api项目模板，或通过CLI执行dotnet new webapi -n CatchException。运行后将访问至Swagger页面。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:1:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"集成Abp 首先需要添加Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc Nuget包引用至项目中以集成Abp框架。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Abp应用 Abp框架中定义了IAbpApplication应用，这也是Abp项目的入口点，Abp应用包含了启动模块及其依赖。在项目启动时需要将Abp应用注册到依赖注入系统中去，并指定启动模块。Abp定义了AddApplication泛型扩展方法，它将Abp应用注册为单例，方法的泛型参数指定了启动模块。 通过WebApplicationBuilder编译得到WebApplication后，调用Abp定义的扩展方法InitializeApplication，他将初始化Abp应用，根据模块的依赖关系初始化启动模块及其依赖的模块。 var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:1","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"模块 Abp设计为模块化的应用程序框架，每一个模块都应定义一个继承自AbpModule的类，并以Module后缀作为类名。不同的模块间会存在依赖关系，模块的依赖关系通过DependsOn特性来定义。每个C#项目只应定义一个模块。 在ConfigureServices方法中，可以将依赖项注册到依赖注入系统中。在Abp中，通过约定大于配置的方式进行依赖项注册，项目代码通常无需在这里手动注册。ConfigureServices方法将在实例化Abp应用的时候调用以进行依赖项注册。 初始化Abp应用时，将会按照依赖顺序初始化所有的模块。初始化启动项模块时将会调用OnApplicationInitialization方法，通常在这个方法中会构建中间件管道。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); app.UseConfiguredEndpoints(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:2","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"Swagger 添加Nuget包引用Volo.Abp.Swashbuckle及其模块依赖。Abp对Swagger进行了一些功能上的完善，比如防止跨站点请求伪造攻击，因此在项目中需要使用Volo.Abp.Swashbuckle。Volo.Abp.Swashbuckle自定义了swagger所需的js文件，他位于Volo.Abp.Swashbuckle模块的wwwroot文件夹中，因此需要通过UseStaticFiles扩展方法添加静态文件中间件支持。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpSwashbuckleModule))] public class CatchExceptionModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { ConfigureSwaggerServices(context); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); app.UseRouting(); if (env.IsDevelopment()) { app.UseSwagger(); app.UseAbpSwaggerUI(c =\u003e { c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"CatchException API\"); }); } app.UseConfiguredEndpoints(); } private static void ConfigureSwaggerServices(ServiceConfigurationContext context) { context.Services.AddAbpSwaggerGen(); } } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:3","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"日志 添加Nuget包引用Serilog.AspNetCore、Serilog.Sinks.Async到项目中。 在应用程序启动时，首先创建一个Serilog日志记录器，然后将构建并运行Web应用的操作通过try块包括起来捕获异常，在catch块中记录启动异常日志，在finally块中重置Serilog日志记录器。上述操作针对启动过程进行了日志记录，若要使应用通过Serilog记录日志，还需要UseSerilog扩展方法注册Serilog日志服务。更改Program.cs。 try { Log.Logger = new LoggerConfiguration() #if DEBUG .MinimumLevel.Debug() #else .MinimumLevel.Information() #endif .MinimumLevel.Override(\"Microsoft\", LogEventLevel.Information) .Enrich.FromLogContext() .WriteTo.Async(c =\u003e c.File(\"Logs/logs-.txt\", rollingInterval: RollingInterval.Day)) #if DEBUG .WriteTo.Async(c =\u003e c.Console()) #endif .CreateLogger(); var builder = WebApplication.CreateBuilder(args); builder.Host .UseAutofac() .UseSerilog(); builder.Services.AddApplication\u003cCatchExceptionModule\u003e( options =\u003e { options.Services.ReplaceConfiguration(builder.Configuration); }); var app = builder.Build(); app.InitializeApplication(); await app.RunAsync(); return 0; } catch (Exception ex) { Log.Fatal(ex, \"Host terminated unexpectedly!\"); return 1; } finally { Log.CloseAndFlush(); } ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:4","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"启动 启动应用此时应导航到Swagger页面并可调用WeatherForecast接口获取数据。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:2:5","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":["Abp极简教程"],"content":"总结 这篇文章展示了如何从ASP.NET Core Web Api模板开始，手动集成Abp框架并将项目模块化，以当前项目作为启动模块创建并运行Abp应用。这里简单介绍了Abp应用及Abp模块，后续文章将逐步介绍Abp中的其他概念及用法。 ","date":"2021-12-23","objectID":"/posts/abp-tutorial-1-application-and-module/:3:0","tags":["Tutorials","Abp"],"title":"Abp极简教程-1 应用和模块","uri":"/posts/abp-tutorial-1-application-and-module/"},{"categories":[".NET"],"content":"如何在生命周期为Singleton的服务中，解析生命周期为Scoped或Transient的依赖项。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"在依赖注入系统中，依赖项的生命周期通常分为瞬时的（Transient）、作用域的（Scoped）、单例的（Singleton）三种。单例生命周期的服务通常会在首次调用时创建，后续每此调用都会使用同一实例。 单例服务若依赖其他生命周期为瞬时或作用域的服务时，无法通过构造函数注入依赖项。构造函数只会在创建实例时调用一次，若将依赖项通过构造函数注入并赋值给单例服务的本地成员，依赖项的生命周期结束后销毁后，指向依赖项的本地成员将会指向空引用，且永远不会再次被赋值（只在调用构造函数时赋值）。运行时会抛出异常Cannot consume scoped service 'XXX' from singleton 'XXX'.。 ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:0:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":[".NET"],"content":"解决方案 在依赖瞬时生命周期或作用域生命周期依赖项的单例服务中，不直接通过构造函数注入依赖项，而是注入IServiceScopeFactory，在需要用到依赖项的方法中，通过IServiceScopeFactory创建作用域并解析依赖项。 public class MySingletonService : IMySingletonService { private readonly IServiceScopeFactory _scopeFactory; public MySingletonService(IServiceScopeFactory scopeFactory) { _scopeFactory = scopeFactory; } public void Scoped() { using var scope = _scopeFactory.CreateScope(); var ctx = scope.ServiceProvider.GetRequiredService\u003cMyDbContext\u003e(); } } ","date":"2021-12-22","objectID":"/posts/resolve-dependencies-in-singleton-service/:1:0","tags":["dependency injection",".NET"],"title":"在单例服务中解析依赖项","uri":"/posts/resolve-dependencies-in-singleton-service/"},{"categories":["ASP.NET Core"],"content":"配置在开发环境中使用HTTP而不是HTTPS，配置不同的端口号。","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["ASP.NET Core"],"content":"在开发ASP.NET Core的项目时，默认地是使用HTTPS安全协议的。有时候可能不希望在本地的开发环境中使用HTTPS，更改这一默认行为非常简单。 移除UseHttpsRedirection中间件 app.UseHttpsRedirection中间件会将所有HTTP请求重定向到HTTPS，因此首先我们需要将其删除。中间件配置一般在Program.cs或Startup.cs中。 配置launchSettings.json launchSettings.json在项目的Properties目录下，它只对本地的开发环境生效，部署时会被忽略。通过dotnet new或者Visual Studio生成的ASP.NET Core项目会创建launchSettings.json文件。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 44324 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"https://localhost:7072;http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 将applicationUrl从https更改为http即可更改默认的应用启动Url，若使用IIS启动，还需将iisSettings中的sslPort设为0。 { \"iisSettings\": { \"windowsAuthentication\": false, \"anonymousAuthentication\": true, \"iisExpress\": { \"applicationUrl\": \"http://localhost:16717\", \"sslPort\": 0 } }, \"profiles\": { \"WebApplication1\": { \"commandName\": \"Project\", \"dotnetRunMessages\": true, \"launchBrowser\": true, \"applicationUrl\": \"http://localhost:5072\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } }, \"IIS Express\": { \"commandName\": \"IISExpress\", \"launchBrowser\": true, \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } } 此外，在launchSettings.json中，也可以通过applicationUrl更改应用启动的端口号。 ","date":"2021-12-22","objectID":"/posts/configure-protocol-and-port/:0:0","tags":["ASP.NET Core"],"title":"禁用ASP.NET Core开发环境的HTTPS","uri":"/posts/configure-protocol-and-port/"},{"categories":["abp"],"content":"在Abp框架中，如何将ExtraProperties额外属性作为查询条件进行数据检索。","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"Abp框架提供了实体扩展系统，允许在不对类的定义进行更改的情况下，向对象中添加额外的属性。默认地，额外属性是以json对象的形式存储在数据库表的ExtraProperties字段中，因此无法直接将额外属性作为查询条件。对于额外属性，Abp支持将其通过Entity Framework Core映射为数据库表的单独字段，因此我们可以利用数据库映射来实现根据额外属性进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:0:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"数据库映射 将额外属性映射为数据库表字段非常容易。 通过Abp启动模板创建的解决方案中，预先生成了处理数据库映射的*EfCoreEntityExtensionMappings类，它位于*.EntityFrameworkCore项目中。在项目启动时，将会执行其中的Configure方法，通过OneTimeRunner执行一次操作。 在OneTimeRunner.Run()方法的Action参数中，通过ObjectExtensionManager来处理额外属性到数据库表字段的映射。 ObjectExtensionManager.Instance .AddOrUpdateProperty\u003cIdentityUser, string\u003e( \"Gender\", options =\u003e { options.MapEfCore((b, p) =\u003e { b.HasIndex(\"Gender\"); p.IsRequired().HasDefaultValue(string.Empty); p.HasMaxLength(8); }); } ); 在AddOrUpdateProperty方法中还可以设置表字段长度等，也可设置表的属性如索引。 添加数据迁移脚本并运行*.DbMigrator更新数据库接口，可以看到表中多出一个名为Gender的字段。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:1:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"查询 在*.EntityFramework.Core项目中创建仓储，并创建查询方法。 public async Task\u003cIdentityUser\u003e GetUserByGenderAsync(string gender) { return await (await GetDbSetAsync()) .FromSqlRaw($\"select * from AbpUsers where Gender == '{gender}'\") .FirstOrDefaultAsync(); } 调用方法GetUserByGenderAsync并传入gender参数即可根据Gender进行查询。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:2:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["abp"],"content":"总结 在这篇文章中，描述了如何对额外属性进行数据库映射，以及将额外属性作为查询条件检索数据。值得注意的是，将额外属性作为查询条件并不是最佳实践，如果可能的话应当尽量避免。此外，如需将拥有额外属性的Entity通过AutoMapper映射为Dto，不要忘记对Dto进行扩展并配置AutoMapperProfile。 ","date":"2021-12-17","objectID":"/posts/query-by-extra-properties-in-abp/:3:0","tags":["abp"],"title":"在Abp中根据ExtraProperties进行查询","uri":"/posts/query-by-extra-properties-in-abp/"},{"categories":["maui"],"content":"如何在Maui中使用依赖注入","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"依赖关系注入(DI)是 .NET 中的一等公民，如果熟悉 .NET 开发，对依赖注入则不会陌生。依赖关系注入是一种在类及其依赖关系之间实现控制反转(IoC)的技术，其中要反转的是获取依赖项的过程。通过依赖关系注入，分离了对象构建和对象使用的关注点，提高了代码的可读性和重用性。 .NET Multi-platform App UI 框架支持依赖关系注入软件设计模式。在 MVVM 模式中，依赖注入通常用于注册和解析视图模型，并注册和解析视图模型所依赖的服务。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:0:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"容器 容器负责构造并注入服务，管理服务的生命周期。拥有依赖项的类，只需关注对于依赖项的使用，无需关注依赖项的创建与管理——这个过程由容器进行处理。.NET 中提供了内置的服务容器IServiceProvider，可以使用IServiceProvider来解析依赖的服务。 一般地，在应用程序启动时，将服务注册到IServiceCollection中，然后调用BuildServiceProvider扩展方法，即可得到IServiceProvider容器。 在 Maui 中，生成IServiceProvider的过程是框架自动完成的，只需要在MauiProgram.cs中将服务注册到IServiceCollection即可。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:1:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注册服务 在注入服务前，必须先将服务注册到容器中。Maui 内置的容器ISeviceProvider位于MauiApp中。 应用程序启动时，调用MauiProgram.cs中的 CreateMauiApp设置并构造MauiApp。首先调用 CreateBuilder创建一个构造器，通过这个构造器完成创建MauiApp所需的全部设置，其中包括服务注册，最终通过Build方法构造 MauiApp 实例。 public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp\u003cApp\u003e() .ConfigureFonts(fonts =\u003e { fonts.AddFont(\"OpenSans-Regular.ttf\", \"OpenSansRegular\"); }); return builder.Build(); } } 在.NET中注册服务，就是在应用程序启动时，将服务注册到 IServiceCollection 中。在MauiAppBuilder中，存在IServiceCollection类型的属性Services。因此，在 Maui 应用程序中注册服务，只需在构造MauiApp时将服务添加到MauiAppBuilder中的 Services中。 public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); ... builder.Services.AddSingleton\u003cMainPage\u003e(); return builder.Build(); } 在进行依赖关系注入时，需要从容器中解析服务。通过调用IServiceCollection的扩展方法 BuildServiceProvider可以构造获取 IServiceProvider容器实例。 调用MauiAppBuilder的Build方法获取 MauiApp实例时，将调用BuildServiceProvider，构造出IServiceProvider并赋值给MauiApp中的Services属性。 ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:2:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["maui"],"content":"注入服务 注册服务后，可以通过容器来解析服务实例，也可将其作为依赖项进行注入。 依赖关系注入通常有构造函数注入、属性注入与方法注入三种方式。在 Maui 中，一般会使用构造方法注入依赖项，在平台代码中有时也会直接通过MauiApp实例来解析依赖项。 public partial class App : Application { public App(MainPage mainPage) { InitializeComponent(); MainPage = mainPage; } } 将MainPage注册到容器中后，可以通过构造函数注入的方式将其作为依赖项注入。在特定平台的代码中，有时无法使用构造函数注入，这时可以直接通过容器解析依赖项。 public class MyActivity : MauiAppCompatActivity { private readonly IHelloService _helloService; public MyActivity() { _helloService = MauiApplication.Current.Services.GetRequiredService\u003cIHelloService\u003e(); } } ","date":"2021-10-27","objectID":"/posts/dependency-injection-in-maui/:3:0","tags":["dependency injection","maui"],"title":"如何在Maui中使用依赖注入","uri":"/posts/dependency-injection-in-maui/"},{"categories":["Abp"],"content":"轻量化Abp框架","date":"2021-07-23","objectID":"/posts/lightweightabp/","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"在进行框架的选型时，经常会听到“***框架太重了”之类的声音，比如“Abp太重了，不适合我们…”。事实上，Abp框架真的很重吗？ 框架的“轻”和“重”，我没有在网上找到明确的定义，通过阅读一些技术博客，大致可以把框架的“轻”和“重”通过以下几个方面进行区分： 所依赖程序集的数量 所实现的功能的多少 上手难度及易用性 “轻量级”的框架，大概指的是一个程序集依赖少且程序集文件小、功能虽少但足够满足需求、上手容易使用简单的框架；“重量级”的框架，大概指的是一个程序集依赖多且程序集文件大、功能丰富但大多数用不到、上手困难且使用困难的框架。 这篇文章将从上述几个方面来探索Abp是一个“轻量级”还是“重量级”的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:0:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"最小依赖 Abp开发了一些启动模板来为我们生成项目。启动模板采用了领域驱动设计的分层方案来建立项目层级，包括了展示层、应用层、领域层与基础设施层。 我们通常都会通过Abp CLI或Abp.io来创建类似上图架构的项目。Abp为我们生成的项目，减少了我们初始化项目的工作量，开箱即用，因此将我们可能会使用的Nuget包预先引入到我们的项目中，也就给我们一种依赖项太多的感觉。 从架构设计上来讲，模块化是Abp的核心；而从技术角度来看，依赖注入则是Abp实现众多功能的一个主要手段。只要了解Abp的模块化和依赖注入，我们就能够基于Abp框架来进行项目开发。 接下来将创建一个原生的ASP.NET Core Web API项目，围绕模块化和依赖注入两个核心概念，来展示如何以最小依赖的方式使用Abp。 通过VS或者dotNet cli新建一个原生的ASP.NET Core Web API项目，命名为LightweightAbp； 安装Nuget包Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc； 将项目进行模块化：在项目根目录新建一个Abp模块代码文件LightweightAbpModule.cs，并复制以下代码： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { } public override void OnApplicationInitialization(ApplicationInitializationContext context) { } } 将Startup中的代码调整到LightweightAbpModule中，代码如下： [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule))] public class LightweightAbpModule : AbpModule { public override void ConfigureServices(ServiceConfigurationContext context) { context.Services.AddControllers(); context.Services.AddSwaggerGen(c =\u003e { c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"LightweightAbp\", Version = \"v1\" }); }); } public override void OnApplicationInitialization(ApplicationInitializationContext context) { var app = context.GetApplicationBuilder(); var env = context.GetEnvironment(); if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); app.UseSwagger(); app.UseSwaggerUI(c =\u003e c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"LightweightAbp v1\")); } app.UseRouting(); app.UseAuthorization(); app.UseEndpoints(endpoints =\u003e { endpoints.MapControllers(); }); } } 更改Startup中的代码以使用Abp的模块化系统： public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddApplication\u003cLightweightAbpModule\u003e(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ILoggerFactory loggerFactory) { app.InitializeApplication(); } } 更改Program的CreateHostBuilder方法以使用Abp的依赖注入系统（基于Autofac）： public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u003e { webBuilder.UseStartup\u003cStartup\u003e(); }) .UseAutofac(); 将项目生成的WeatherForecastController基类ControllerBase更改为AbpController。 按F5运行。 至此项目的创建完成了。可以看到，仅仅依赖了Volo.Abp.Autofac和Volo.Abp.AspNetCore.Mvc两个Nuget包，即可利用Abp进行开发。若从所依赖Nuget包数量来评估框架的“轻”和“重”，那么Abp不可谓不轻。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:1:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"功能按需使用 得益于模块化设计，Abp将其所能提供的功能，划分并封装到了不同的模块中。要想使用Abp提供的某一功能，只需引入相关的Nuget包并依赖（DependsOn）模块即可。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"数据访问 要想实现数据访问功能，首先我们需要定义Entity、DbContext并配置数据库支持。在Abp的层次架构中，Entity、Repository属于领域层，Service属于应用层，DbContext则属于EntityFramework Core模块，因此我们按需引入所需模块即可。 安装Nuget包Volo.Abp.Ddd.Application、Volo.Abp.Ddd.Domain和Volo.Abp.EntityFrameworkCore.Sqlite； 在LightweightAbpModule类中配置DependsOn特性，将AbpDddApplicationModule、AbpDddDomainModule和AbpEntityFrameworkCoreSqliteModule模块依赖到我们的项目模块中。 [DependsOn( typeof(AbpAutofacModule), typeof(AbpAspNetCoreMvcModule), typeof(AbpDddApplicationModule), typeof(AbpDddDomainModule), typeof(AbpEntityFrameworkCoreSqliteModule))] public class LightweightAbpModule : AbpModule { ... } 然后创建实体Book及数据库上下文LightweightAbpDbContext: using System; using Volo.Abp.Domain.Entities; namespace LightweightAbp { public class Book : Entity\u003cGuid\u003e { public string Name { get; set; } } } [ConnectionStringName(\"Default\")] public class LightweightAbpDbContext : AbpDbContext\u003cLightweightAbpDbContext\u003e { public LightweightAbpDbContext(DbContextOptions\u003cLightweightAbpDbContext\u003e options) : base(options) { } public DbSet\u003cBook\u003e Books { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); builder.Entity\u003cBook\u003e(b =\u003e { b.ToTable(nameof(Books)); }); } } 在LightweightAbpModule的ConfigureServices方法中配置数据库访问： public override void ConfigureServices(ServiceConfigurationContext context) { ... context.Services.AddAbpDbContext\u003cLightweightAbpDbContext\u003e(options =\u003e { options.AddDefaultRepositories(includeAllEntities: true); }); Configure\u003cAbpDbContextOptions\u003e(options =\u003e { options.UseSqlite(); }); } 在appsettings.json中配置数据库连接字符串 { ... \"ConnectionStrings\": { \"Default\": \"Data Source=LightweightAbp.db\" } } 安装Nuget包\"Microsoft.EntityFrameworkCore.Tools\",并在在项目根目录下打开命令行工具，依次执行以下命令进行数据迁移和数据库更新： dotnet ef migrations add InitialCreate dotnet ef database update 创建IBookAppService及BookAppService: public interface IBookAppService { Task CreateAsync(string name); } public class BookAppService : ApplicationService, IBookAppService { public IRepository\u003cBook, Guid\u003e Repository =\u003e LazyServiceProvider.LazyGetRequiredService\u003cIRepository\u003cBook, Guid\u003e\u003e(); public async Task\u003cstring\u003e CreateAsync(string name) { var book = await Repository.InsertAsync(new Book() { Name = name }); return book.Name; } } 在文件夹Controllers中创建BookController: [ApiController] [Route(\"[controller]\")] public class BookController : AbpController { private readonly IBookAppService _service; public BookController(IBookAppService service) { _service = service; } [HttpGet] public Task\u003cstring\u003e CreateAsync(string name) { return _service.CreateAsync(name); } } F5以调试模式运行即可在Swagger页面上插入数据： 这里我们实现了简单的数据插入。可以看到，项目中并没有使用复杂架构和复杂的领域驱动设计，仅引用并配置Abp模块，即可使用常规的 ASP.NET Core Web API方式进行开发。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:1","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"缓存 接下来我们将继续实现缓存功能。 引用Nuget包Volo.Abp.Caching并向LightweightAbpModule添加AbpCachingModule模块依赖； 修改IBookAppService及BookAppService实现GetAllAsync方法： public interface IBookAppService { Task\u003cstring\u003e CreateAsync(string name); Task\u003cstring[]\u003e GetAllAsync(); } public class BookAppService : ApplicationService, IBookAppService { private readonly IRepository\u003cBook, Guid\u003e _repository; private readonly IDistributedCache\u003cstring[]\u003e _cache; public BookAppService( IRepository\u003cBook, Guid\u003e repository, IDistributedCache\u003cstring[]\u003e cache) { _repository = repository; _cache = cache; } public async Task\u003cstring\u003e CreateAsync(string name) { ... } public async Task\u003cstring[]\u003e GetAllAsync() { return await _cache.GetOrAddAsync( \"AllBooksName\", async () =\u003e await _repository.Select(b =\u003e b.Name).ToArrayAsync(), () =\u003e new DistributedCacheEntryOptions { AbsoluteExpiration = DateTimeOffset.Now.AddHours(1) } ); } } 修改BookAppService实现GetAllAsyncAPI接口： public class BookController : AbpController { ... [HttpGet(\"all\")] public Task\u003cstring[]\u003e GetAllAsync() { return _service.GetAllAsync(); } } F5以调试方式运行，即可调用实现了缓存功能的GetAllAsync接口。 这里我们实现了缓存功能。显而易见，按需使用缓存功能所在的Nuget包及模块即可，并没有很多繁杂的操作。 众所周知，Abp实现了相当多的功能，其中有些功能也许整个项目生命周期中都不会用到。得益于模块化的方式，我们可以只依赖我所需要的Nuget包和Abp模块。如果根据功能多少来评判框架的“轻”和“重”，我们按需依赖不同模块时Abp框架不可谓不轻。由此可见，一个框架的“轻”和“重”，有时还会取决于使用方式。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:2:2","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"上手难度及易用性 学习一门新技术最好的起点便是官方文档，Abp也是如此，Abp的官方文档非常详尽介绍了各个功能。Abp还为我们提供了启动模板，模板遵循了领域驱动设计的最佳实践来进行项目分层，并且为我们继承了很多项目中常用的功能模块。 对于初学者而言，面对一个复杂的分层架构及丰富的功能特性支持，一瞬间需要接受非常多的知识，因此会产生无从下手的感觉，进而得出一种上手难度高，框架很“重”的结论。 如果从另外一种角度来学习Abp的话，也许情况会有所不同。在本文之初，我便提出了Abp的核心是模块化及依赖注入的观点，当我们将入门的重点放在模块化和依赖注入上，那么会发现Abp是一个极易上手并且学习曲线很平缓的框架。正如上文我所进行的代码演示，如果感觉这个演示项目简单易学，那么就证明了我这一观点。 至于易用性，首先Abp实现的功能很全面，我们可以按需使用；其次，随着对Abp框架的逐步深入，会发现模块化的设计让我们的项目集成多种功能变得简单，并且随着项目的演进，Abp的模块化给我们提供了轻易切换到微服务方案的能力；依赖注入系统让我们能够轻易的定制并替换Abp默认实现的功能。因此，我认为Abp是一个易于使用的框架。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:3:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"总结 在这里我们从一个不同的角度来认识了Abp框架，显而易见，对于Abp来讲，是否太“重”，和我们对他的认知及使用方式有很大的关联。 项目示例代码将托管在Github中。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:4:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"},{"categories":["Abp"],"content":"致谢 感谢Abp群（QQ群：48039003）的群友们提供的热心帮助。 ","date":"2021-07-23","objectID":"/posts/lightweightabp/:5:0","tags":["Abp"],"title":"Abp太重了？轻量化Abp框架","uri":"/posts/lightweightabp/"}]